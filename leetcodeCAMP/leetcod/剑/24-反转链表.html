<!DOCTYPE html>
<html>
<head>
	<title></title>
</head>
<body>
	<p>输入: 1->2->3->4->5->NULL</p>
	<p>输出: 5->4->3->2->1->NULL</p>

	<script type="text/javascript">
		const mylist = {
		 	val:1,
		 	next:{
		 		val:2,
		 		next:{
		 			val:3,
		 			next:{
		 				val:4,
		 				next:{
		 					val:5,
		 					next:null
		 					}
		 				}
		 			}
		 		}
		 	};

		 //递归/栈


		//迭代
		const reverseList = function(head) {
			let pre = null; // 这里修改一下，pre只是一个值，不是一个node.

			
			let cur = head;


			// 当cur不是空节点时，这么写可以指到最后一个节点；
			// 如果写成while(cur.next);当cur.next不为空，这么写只能指到倒数第2个节点。
			while(cur){  
				let tmp= cur.next; 
				cur.next = pre;
				pre = cur;
				cur = tmp;

			}

			//console.log(cur);
			return pre;


		};

		//reverseList(mylist);
	</script>

	<p>25.合并两个排序的链表</p>
	<p>输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。</p>
	<script type="text/javascript">
		const myl1 = {
		 	val:1,
		 	next:{
		 		val:2,
		 		next:{
		 			val:4,
		 			next:null
		 			}
		 		}
	 	};

	 	const myl2 = {
		 	val:1,
		 	next:{
		 		val:3,
		 		next:{
		 			val:4,
		 			next:null
		 			}
		 		}
	 	};

	 	// 思路1： 建立第三个链表，一个个往上面穿节点
	 	const mergeTwoLists1 = function(l1, l2) {
	 		let dump = {
	 			val:null,
	 			next:null
	 		};

	 		let head = dump;

		// 如果用 && 需要两个链表同时不为空，那走到最后一位的时候，有一个节点就会漏掉；
		// 如果用 || 当有空节点时，
	 		while(l1 && l2){  
	 			if(l1.val <= l2.val){
	 				dump.next = l1;
	 				l1 = l1.next;
	 			} else {
	 				dump.next = l2;
	 				l2 = l2.next;
	 			};

	 			dump = dump.next; 
	 			//console.log(dump);

	 		};

	 		(l1 != null) ? dump.next=l1 : dump.next=l2; // 加了这句 可以把最后一个节点也加进dump里。

	 		return head.next;

		};


		//思路2：在原链表上插入新值  递归待补充
		const mergeTwoLists = function(l1, l2) {

		}


		//mergeTwoLists(myl1,myl2);


		
	</script>

</body>
</html>