<!DOCTYPE html>
<html>
<head>
	<title></title>
</head>
<body>
	<p>114.二叉树的前序遍历</p>
	<p>94. 二叉树的中序遍历</p>
	<script type="text/javascript">
		 let myroot = {
			val:1,
			left:{
				val:2,
				left:{val:8,
					  left:null,
					  right:null
					 },
				right:{val:9,
					  left:null,
					  right:null
					 }
			},
			right:{
				val:5,
				left:{val:4,
					  left:null,
					  right:null
					 },
				right:{val:3,
					  left:null,
					  right:null
					 }
			}
		};

		/**
		 * @param {TreeNode} root
		 * @return {number[]}
		 */


		 // recursion 递归
		const preorderTraversal1 = function(root) {
			let res = [];

			function dfs(root) {
				if(root === null) return;
				res.push(root.val);
				dfs(root.left);
				dfs(root.right);
			};

			dfs(root);

			return res;

		};

		//简洁写法
		//const preorderTraversal2 = function(root) {
		//    return root ? [root.val, ...preorderTraversal(root.left), ...preorderTraversal(root.right)] : []
		//};




		// iteration 迭代
		//本质上是在模拟递归，因为在递归的过程中使用了系统栈，所以在迭代的解法中常用Stack来模拟系统栈。
		const preorderTraversal3 = function(root) {
			//if(!root) return [];

			let stack = [], res = [];
            if(root) stack.push(root);

			while(stack.length >0){
				let node = stack.pop();
				if(node) res.push(node.val);
				if(node.right) {
					stack.push(node.right);
				};
				if(node.left) {
					stack.push(node.left);
				};
			}

			return res;


		};


		//迭代另外一种写法。
		// 它先将根节点 cur 和所有的左孩子入栈并加入结果中，直至 cur 为空
		const preorderTraversal = function(root) {
			//if(!root) return [];

			let stack = [], res = [], cur = root;

			while(stack.length>0 || cur){
				while(cur){
					res.push(cur.val);
					stack.push(cur);
					cur = cur.left;
				}
				let tmp = stack.pop();
				cur = tmp.right;
			}

			return res;

		}

		preorderTraversal(myroot); //[1, 2, 8, 9, 5, 4, 3]

		
	</script>

	<script type="text/javascript">
		const inorderTraversal1 = function(root) {
			let res = [];

			const dfs = function(node){
				if(!node) return ;
				dfs(node.left);
				res.push(node.val);
				dfs(node.right);
			}

			dfs(root);
			return res;

		};

		// Depth first  先左枝走到最底，1-2-8， 然后弹出最后一个节点，并将其值push到结果中。
		// 指针指到8.right, 不满足进栈条件，继续弹出现有栈内元素，2，并push值到res；
		// 2.right满足进栈条件，当前栈为1-9；
		//将9弹出，返回，栈内只剩下1；
		//开始遍历1的右子树。

		const inorderTraversal2 = function(root) {
			let res = [], stack = [], cur = root;

				while(stack.length >0 || cur) {
					while(cur){
						stack.push(cur);
						cur = cur.left;
						//console.log(root,res);
					}

					
					let node = stack.pop()
					res.push(node.val);
					cur = node.right;

					//console.log(stack);
				}


			return res;

		};


		//迭代2
		const inorderTraversal = function(root) {
			let stack = [], res = [];
            if(root) stack.push(root);

			while(stack.length >0){
				let node = stack.pop();


				if(node.left) {
					stack.push(node.left);
				};
				if(node) res.push(node.val);
				if(node.right) {
					stack.push(node.right);
				};
			}

			return res;

		}



		//inorderTraversal(myroot);
	</script>

</body>
</html>