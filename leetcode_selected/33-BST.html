<!DOCTYPE html>
<html>
<head>
	<title>Binary Search Tree</title>
</head>
<body>
	<p>剑指 Offer 33. 二叉搜索树的后序遍历序列</p>

	<script type="text/javascript">
		//剑指 Offer 33. 二叉搜索树的后序遍历序列
		//postorder最后一位为root, 根据postorder中第一位大于root的值的位置，划分出左右子树。
		//左子树中每个值都小于root，右子树中每个值都大于root.


		const verifyPostorder1 = function(postorder) {
			if(postorder.length <=2)return true; // ！！！进栈动作的终止条件 到达叶子节点？

			let root = postorder.pop();

			let i=0;
			for(i; i<postorder.length;i++){
				if(postorder[i] > root)	break;
			};

			let lefttree = postorder.slice(0,i);
			let righttree = postorder.slice(i); 

			const rightResult = righttree.every(item => item>root);


			return rightResult && verifyPostorder(lefttree)&&verifyPostorder(righttree);

		};

		//verifyPostorder([1,3,2,6,5])

		//K神版
		const verifyPostorder = function(postorder) {
			const recur = function(i,j) {
				// 例如当 i = m = j - 1 时，向下递归 recur(i, m - 1) 时 i > j ，本质上就是左子树为空的情况
				if (i>=j) return true; 
				let p=i;
				while(postorder[p] < postorder[j]) p += 1;
				let m=p;//for get the index of the first element of right tree
				while(postorder[p] > postorder[j]) p += 1;

				return p===j &&	recur(i,m-1) && recur(m,j-1);
			};

			return recur(0, postorder.length-1);

		};

		//解法2：单调栈

		
	</script>

</body>
</html>