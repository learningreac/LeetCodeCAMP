<!DOCTYPE html>
<html>
<head>
	<title></title>
</head>
<body>
	<p><b>剑指offer 03. 数组中的重复数字</b></p>
	<P>在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。</P>
	<P>数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。</P>

	<h3>思路</h3>
	<p>思路1：If use Array methods like slice and includes, 会超时，而且牵涉到method背后本身的逻辑.</p>
	<p>思路2：暴力遍历，若num[i]等于nums[i+1],则重复。 时间复杂度O(N*N),空间复杂度O(1)</p>
	<p>思路3：遍历1遍，用Harsh table登记Key, 后续若发现记录过，则表示出现过。</p>
	<p>思路4：原地置换。待补充</p>

	<p><b>剑指 Offer 21. 调整数组顺序使奇数位于偶数前面</b></p>
	<p><b>剑指 Offer 39. 数组中出现次数超过一半的数字</b></p>
	<p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。</p>

	<p><b>剑指 Offer 40. 最小的k个数</b></p>
	<p>TOP K问题</p>

</body>
	<script type="text/javascript">
	/**
	 * @param {number[]} nums
	 * @return {number}
	 */

	const mynums =  [2, 3, 1, 0, 2, 5, 3]

	//method 1: array methods
	const findRepeatNumber1 = function(nums) {
		let i=0;
		let j=nums.length-1;
		let res;

		for(i;i<=j;i++){
			if(nums.slice(i+1).includes(nums[i])){
				return res = nums[i]
			}
		}

	};		


	//method 2 sort first, then use a for loop to check if nums[i] = nums[i+1].
	const findRepeatNumber2 = function(nums) {
		nums.sort((a,b) => a-b);
		let i=0;
		let res;

		for(i;i<nums.length;i++){
			if(nums[i]===nums[i+1]){
				return res = nums[i]
			}
		}

	};


	// method 3: use an harsh table(or Map OBJ) to register the nums
	const findRepeatNumber = function(nums) {
		let dic = new Map();

		for(let i=0;i<nums.length;i++){
			if(dic.get(nums[i]) != undefined){
				return nums[i]
			} else {
				dic.set(nums[i],1)
			}
		}

		console.log(dic);

	};

	findRepeatNumber(mynums);
	</script>


	<script type="text/javascript">
		//21 调整数组的顺序
		//输入：nums = [1,2,3,4], 输出：[1,3,2,4] or [3,1,2,4] 

		//思路：头尾双指针
		// 这样写会出现的问题是，当两个指针移动到各自的最后一个位置，即便指针所指的元素符合各自的条件，但是呢，也会交换，从而返回错误。
		function isodd (val) {
			return val%2==1;
		}
		function iseven (val ) {
			return val%2==0;
		}
		const exchange5 = function(nums) {
					let i = 0, j=nums.length-1;

					while(true){
						if(isodd(nums[i])) 
							i++;
						if(iseven(nums[j]))
							j--; 
						//console.log(i,j);
						if(i>=j) break;
						if(iseven(nums[i]) && isodd(nums[j]) ){
							[nums[i],nums[j]] = [nums[j], nums[i]];
							i++;
		                    j--;
						};
						
					}
					return nums;

		};
		
		const exchange = function(nums) {
					let i = 0, j=nums.length-1;

					//满足条件A，则执行条件A；
					//不满足条件A，判断是否满足条件B；
					//A和B都不满足，则执行条件C。
					while(i<j){
						if(isodd(nums[i])) //条件A
							i++;
						else if(iseven(nums[j])) //条件B
							j--; 
						else //条件C
						{
							[nums[i],nums[j]] = [nums[j], nums[i]];
							i++;
		                    j--;
						}
						
					}
					return nums;

		};

		//exchange([1,2,3,4]);
		//exchange([11,9,3,7,16,4,2,0]) // 遇到这个数组，就会报错。
		//exchange([16,9,15,4,5])

		// 改良之后的代码
		const exchange0 = function(nums) {
			let i = 0, j=nums.length-1;

			while(i<j){
				if(nums[i]%2 !==0){ // 左侧为奇数时，指针向右一位
					i++;
					continue;
				};
				if(nums[j]%2 ==0){  // 右侧为偶数时，指针向左一位
					j--; 
					continue; 
				};
				
				[nums[i],nums[j]] = [nums[j], nums[i]];
				
			}
			return nums;

		};



		//思路2.
		// 一个指针，当指针指向偶数时，与尾部交换。 因为不确定交换之后的元素是奇是偶，所以此时i-- 指针向左退回一位。
		// 尾部指针不做奇偶判断，但是当发生一次交换之后，可以确定尾部当前为偶数，所以指针可以向左移一位。
		// 这种思路可行，但是还是会进行一些冗余的交换，比如[11,9,3,7,16,4,2,0]这个数组，当i已经向前移动到16这个元素时，接下来的交换就很重复。
		const exchange2 = function(nums) {
			let i = 0, j=nums.length-1;
			while(i<j) {
				if(nums[i]%2 !==0) i++; //指向奇数，指针向前移动一位；
				if(nums[i]%2 === 0) { //指向偶数，与数组尾部交换，然后i--;
					[nums[i],nums[j]] = [nums[j],nums[i]];
					console.log(nums);
					i--;
					j--;
				}
			}
			return nums;
		}
	</script>


	<script type="text/javascript">
		//39. majority element 数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。
		//输入: [1, 2, 3, 2, 2, 2, 5, 4, 2], 输出：2
		//1.哈希表统计法
		//2.排序，数组中点为出现次数超过一半的数
		//3.摩尔投票法：核心理念为 票数正负抵消 。此方法时间和空间复杂度分别为 O(N)O(N) 和 O(1)O(1) ，为本题的最佳解法。
		const majorityElement1 = function(nums) {
			if(nums.length===1) return nums;

			let halfLength = nums.length/2;

			let numMap = new Map();

			for(let i = 0; i<nums.length; i++){
				if(numMap.has(nums[i])){
					let val = numMap.get(nums[i]);
					numMap.set(nums[i],++val);
					if(val >= halfLength) return nums[i];
				} else {
					numMap.set(nums[i],1);
				};
			}


		};

		//majorityElement([1, 2, 3, 2, 2, 2, 5, 4, 2]);

		// 用object 构造hash table
		var majorityElement2 = function(nums) {

		    const max = nums.length/2, 
		          hash = Object.create(null)

		    for (const num of nums) {
		        hash[num] ? hash[num]++ : (hash[num] = 1)
		        if (hash[num] >= max) return num
		    }
		};



		//摩尔投票法
		//时间复杂度 O(N)： N 为数组 nums 长度。
		//空间复杂度 O(1)： votes 变量使用常数大小的额外空间。
		const majorityElement = function(nums) {
			let votes = 0, cur = 0;

			nums.forEach(num => {
				if(votes === 0) cur = num; // cur start from the first element in array 
				num === cur? votes +=1 : votes -=1;
			})

			return cur;
		};

	</script>

	<script type="text/javascript">
		//40.剑指 Offer 40. 最小的k个数
		//输入：arr = [0,1,2,1], k = 1; 输出：[0]
		//0 <= k <= arr.length <= 10000 ;0 <= arr[i] <= 10000

		const getLeastNumbers1 = function(arr, k) {

			arr.sort((a,b) => a-b);

			return arr.slice(0,k);

		};


		//quick sort
		const quicksort = function(arr,l,r) {
				//let l=0,r=arr.length-1;
				if (l >= r) return;
				let i=l,j=r;

				while(i<j) {
					if(i<j && arr[j]>=arr[l])
						j--;
					else if(i<j && arr[i]<=arr[l])
						i++;
					else
					{
						[arr[i],arr[j]] = [arr[j],arr[i]];
						console.log(arr);
					}
	
				};

				[arr[l],arr[i]] = [arr[i],arr[l]];

				quicksort(arr,0,i-1);
				quicksort(arr,i+1,r)


				return arr;
		};

		//quicksort([2,4,1,0,3,5],0,5); 


		const getLeastNumbers = function(arr, k) {

		}


		//getLeastNumbers([3,2,1],2)


	</script>

</body>
</html>


