<!DOCTYPE html>
<html>
<head>
	<title></title>
</head>
<body>
	<p><b>剑指offer 03. 数组中的重复数字</b></p>
	<P>在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。</P>
	<P>数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。</P>
	<p>2 <= n <= 100000</p>
	<h3>思路</h3>
	<p>思路1：If use Array methods like slice and includes, 会超时，而且牵涉到method背后本身的逻辑.</p>
	<p>思路2：暴力遍历，若num[i]等于nums[i+1],则重复。 时间复杂度O(N*N),空间复杂度O(1)</p>
	<p>思路3：遍历1遍，用Harsh table登记Key, 后续若发现记录过，则表示出现过。</p>
	<p>思路4：原地置换。待补充</p>

	<p><b>剑指 Offer 21. 调整数组顺序使奇数位于偶数前面</b></p>

</body>
	<script type="text/javascript">
	/**
	 * @param {number[]} nums
	 * @return {number}
	 */

	const mynums =  [2, 3, 1, 0, 2, 5, 3]

	//method 1: array methods
	const findRepeatNumber1 = function(nums) {
		let i=0;
		let j=nums.length-1;
		let res;

		for(i;i<=j;i++){
			if(nums.slice(i+1).includes(nums[i])){
				return res = nums[i]
			}
		}

	};		


	//method 2 sort first, then use a for loop to check if nums[i] = nums[i+1].
	const findRepeatNumber2 = function(nums) {
		nums.sort((a,b) => a-b);
		let i=0;
		let res;

		for(i;i<nums.length;i++){
			if(nums[i]===nums[i+1]){
				return res = nums[i]
			}
		}

	};


	// method 3: use an harsh table(or Map OBJ) to register the nums
	const findRepeatNumber = function(nums) {
		let dic = new Map();

		for(let i=0;i<nums.length;i++){
			if(dic.get(nums[i]) != undefined){
				return nums[i]
			} else {
				dic.set(nums[i],1)
			}
		}

		console.log(dic);

	};

	findRepeatNumber(mynums);
	</script>


	<script type="text/javascript">
		//21 调整数组的顺序
		//输入：nums = [1,2,3,4], 输出：[1,3,2,4] or [3,1,2,4] 

		//思路：头尾双指针
		// 这样写会出现的问题是，当两个指针移动到各自的最后一个位置，即便指针所指的元素符合各自的条件，但是呢，也会交换，从而返回错误。

		/*const exchange = function(nums) {
					let i = 0, j=nums.length-1;

					while(i<j){
						if(nums[i]%2 !==0) i++;
						if(nums[j]%2 ==0) j--; 
						//console.log(i,j);
						if(nums[i]%2 == 0 && nums[j]%2 !== 0){
							[nums[i],nums[j]] = [nums[j], nums[i]];
							i++;
		                    j--;
						};
						
					}
					return nums;

		};
		*/
		//exchange([1,2,3,4]);
		//exchange([11,9,3,7,16,4,2,0]) // 遇到这个数组，就会报错。
		//exchange([16,9,15,4,5])

		// 改良之后的代码
		const exchange0 = function(nums) {
			let i = 0, j=nums.length-1;

			while(i<j){
				if(nums[i]%2 !==0){ // 左侧为奇数时，指针向右一位
					i++;
					continue;
				};
				if(nums[j]%2 ==0){  // 右侧为偶数时，指针向左一位
					j--; 
					continue; 
				};
				
				[nums[i],nums[j]] = [nums[j], nums[i]];
				
			}
			return nums;

		};



		//思路2.
		// 一个指针，当指针指向偶数时，与尾部交换。 因为不确定交换之后的元素是奇是偶，所以此时i-- 指针向左退回一位。
		// 尾部指针不做奇偶判断，但是当发生一次交换之后，可以确定尾部当前为偶数，所以指针可以向左移一位。
		// 这种思路可行，但是还是会进行一些冗余的交换，比如[11,9,3,7,16,4,2,0]这个数组，当i已经向前移动到16这个元素时，接下来的交换就很重复。
		const exchange2 = function(nums) {
			let i = 0, j=nums.length-1;
			while(i<j) {
				if(nums[i]%2 !==0) i++; //指向奇数，指针向前移动一位；
				if(nums[i]%2 === 0) { //指向偶数，与数组尾部交换，然后i--;
					[nums[i],nums[j]] = [nums[j],nums[i]];
					console.log(nums);
					i--;
					j--;
				}
			}
			return nums;
		}
	</script>

</body>
</html>


