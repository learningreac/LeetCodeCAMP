<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title></title>
</head>

<body>
    <script type="text/javascript">
        // 30: min stack
        // helper stack,push min(currentmin, x); pop everytime.

        const MinStack = function () { // can't be defind with arrow function 
            this.stack = [];
            this.stackB = [];
            this.tmp = [];
        };

        MinStack.prototype.push = x => {
            this.stack.push(x);
            if (x <= this.stackB[this.stackB.length - 1] || this.stackB.length === 0) {
                this.stackB.push(x);
            } else {
                while (this.stackB.length >= 0) {
                    this.tmp.push(this.stackB.pop());
                };
                this.stackB.push(x);
                while (this.tmp.length >= 0) {
                    this.stackB.push(this.tmp.pop())
                }
            }
        };

        MinStack.prototype.pop = () => {
            let item = this.stackA[this.stack.length - 1];
            if (item === this.stackB[this.stackB[this.stackB.length - 1]]) {
                this.stackB.pop()
            };
            return this.stack.pop();

        };

        MinStack.prototype.top = () => {
            return this.stack[this.stack.length - 1];
        }

        MinStack.prototype.min = () => {
            return this.stackB[this.stackB.length - 1];

        };

        //从尾到头打印链表 -- 回溯递归
        //内存消耗：40.4 MB , 在所有 JavaScript 提交中击败了10.58%的用户 ----栈桢空间
        const reversePrint = function (head) {
            let res = [];
            const backpath = node => {
                if (!node) return;
                backpath(node.next);
                res.push(node.val)
            };
            backpath(head);
            return res;
        };

        //反转链表   ---递归
        const reverseList = function (head) {

            const recur = (cur, pre) => {
                if (cur === null) return pre;
                res = recur(cur.next, cur);
                cur.next = pre;
                return res;
            }

            return recur(head, null)
        }

            // coppy random list 

            * // Definition for a Node.
            function Node(val, next, random) {
                this.val = val;
                this.next = next;
                this.random = random;
            };
        // the random node may not be created 

        const copyRandomList = function (head) {
            if (!head) return null;
            let node = head;
            let map = new Map();

            while (node) {  // copy no
                map.set(node, new Node(node.val));
                node = node.next;
            };

            // reset node
            node = head;
            while (node) {  // reset node.next and node.random
                map.get(node).next = map.get(node.next) === undefined ? null : map.get(node.ext);
                map.get(node).random = map.get(node.random);
                node = node.next;
            };

            return map.get(head);

        }

        //剑指 Offer 36. 二叉搜索树与双向链表
        const treeToDoublyList = function (root) {
            let res = new Map();
            const dfs = function (node) {
                if (!node) return;
                dfs(node.left);
                res.set(node);
                dfs(node.right);

            };
            dfs(root);
            return res;
        };

        //剑指 Offer 59 - II. 队列的最大值
        // 本来想用类似Minstack的方式 维护辅助栈，但是这样做在本题中行不通
        [

        ]
        // queue是会双头出队的，所以当最大值从队首出队后，maxQ中的最大值就错了。
        /*
        const MaxQueue = function() {
            this.queue = [];
            this.maxQ = []; 
        };
        */
        /**
         * @return {number}
         * 若队列为空 pop_front 和 max_value 需要返回 -1
         */
        /**
        MaxQueue.prototype.max_value = function() {
            if (!this.queue.length) {
                return -1
            } else {
                return this.maxQ[this.maxQ.length -1] 
            }
           
        };
        */
        /** 
         * @param {number} value
         * @return {void}
         */
        /**
        MaxQueue.prototype.push_back = function(value) {
            this.queue.push(value);
            if(this.maxQ.length===0){
                this.maxQ.push(value)
            } else {
                this.maxQ.push( Math.max(value, this.maxQ[this.maxQ.length-1]))
            };
        
        };
        */
        /**
         * @return {number}
         */
        /**
        MaxQueue.prototype.pop_front = function() {
            if(this.queue.length === 0) {
                return -1
            } else {
                this.maxQ.shift();
                return this.queue.shift();
            }
        };
        */

        const MaxQueue = function () {
            this.queue = [];
            this.dequeue = [];
        };

        MaxQueue.prototype.max_value = function () {
            if (!this.queue.length) {
                return -1
            } else {
                return this.dequeue[0]
            }
        };

        MaxQueue.prototype.push_back = function (value) {
            this.queue.push(value);
            if (this.dequeue.length === 0 || this.dequeue[this.dequeue.length - 1] > value) {
                this.dequeue.push(value)
            } else {
                while (this.dequeue[this.dequeue.length - 1] < value) {
                    this.dequeue.pop()
                };
                this.dequeue.push(value)
            }
        };

        MaxQueue.prototype.pop_front = function () {
            if (this.queue.length === 0) {
                return -1
            } else {
                let front = this.queue.shift();
                if (front === this.dequeue[0]) {
                    this.dequeue.shift()
                }
                return front
            }
        };

        //剑指 Offer 57 - II. 和为s的连续正数序列
        //滑动窗口 双指针
        const findContinuousSequence = function (target) {
            let l = 1, r = 1, sum = 1; // 正整数序列
            let res = [];
            while (l < target / 2) {
                if (sum < target) { // 右指针右移
                    r++;
                    sum += r
                }
                if (sum > target) { // 左指针右移

                    sum -= l;
                    l++;
                }
                if (sum === target) {
                    let ans = [];
                    for (let k = l; k <= r; k++) {
                        ans.push(k);
                    };
                    res.push(ans);
                    sum -= l;
                    l++

                }
            }
            return res;
        };

        // findContinuousSequence(9)


        //剑指 Offer 68 - I. 二叉搜索树的最近公共祖先
        //迭代
        const lowestCommonAncestor1 = function (root, p, q) {
            while (root) {
                if (root.val < p.val && root.val < q.val) {
                    root = root.right;
                } else if (root.val > p.val && root.val > q.val) {
                    root = root.left;
                } else {
                    break;
                }
            }
            return root;
        };
        //递归
        const lowestCommonAncestor2 = function (root, p, q) {
            if (root.val < p.val && root.val < q.val) {
                return lowestCommonAncestor(root.right, p, q);
            };
            if (root.val > p.val && root.val > q.val) {
                return lowestCommonAncestor(root.left, p, q)
            }
            return root
        };

        //剑指 Offer 68 - II. 二叉树的最近公共祖先 LCOF
        //先序遍历 
        const lowestCommonAncestor = function (root, p, q) {
            // 叶子节点 或者找到了p 或 q   //// 这里可以直接比较node，不需要比较node.val
            if (root === null || root === p || root === q) return root;
            //先序遍历
            let left = lowestCommonAncestor(root.left, p, q);
            let right = lowestCommonAncestor(root.right, p, q);

            if (left === null) return right;
            if (right === null) return left;

            return root;
        };


        //剑指 Offer 14- I. 剪绳子
        const cuttingRope = function (n) {
            if (n === 2) return 1;
            if (n === 3) return 2;
            let dp = new Array();
            dp[1] = 1;
            dp[2] = 2;
            dp[3] = 3;

            for (let i = 4; i <= n; i++) {
                //let l = Math.floor(i / 2);
                //let r = i - l;
                //product1 = dp[l] * dp[r]
                dp[i] = Math.max(dp[3] * dp[i - 3], dp[2] * dp[i - 2])
            };

            return dp[n];

        };

        // cuttingRope(9);

        //剑指 Offer 64. 求1+2+…+n
        const sumNums = function (n) {
            n > 1 && (n += sumNums(n - 1));   // 逻辑短路
            return n;

        };

        //剑指 Offer 46. 把数字翻译成字符串
        // 取余 取整   js 语言特性 浮点数
        const translateNum1 = function (num) {   /// false
            let res = 0;

            while (Math.floor(num) != 0) {
                let x = num % 10;
                let y = num % 100;

                if (y >= 10 && y <= 25) {
                    res += 2
                    num /= 100;
                } else {
                    res += 1;
                    num /= 10;

                };
            }

            return res;
        };

        // translateNum(26);  // 这么写的话 给个两位数就直接报错了。

        const translateNum = function (num) {
            let a = 1, b = 1, x, y = num % 10;
            while (num != 0) {
                num = Math.floor(num / 10);
                x = num % 10;
                let tmp = 10 * x + y;
                let c = (tmp >= 10 && tmp <= 25) ? a + b : a;
                b = a;
                a = c;
                y = x;
            };
            return a;
        };

        // translateNum(26);

        //剑指 Offer 61. 扑克牌中的顺子
        const isStraight1 = function (nums) {
            nums.sort((a, b) => a - b);
            let count = 0; // how many zeros
            let diff = 0;

            for (let i = 0; i <= 3; i++) {
                if (nums[i] === 0) {
                    count++;
                } else {
                    if (nums[i] === nums[i + 1]) return false;
                    diff += nums[i] - nums[i + 1] + 1;
                    if (Math.abs(diff) > count) return false;
                }
            };

            return count + diff >= 0 // count>diff 说明0多，可以当做任意牌

        };

        //isStraight([1,2,3,4,5]);
        //isStraight([9,1,13,2,13]); //false
        //isStraight([11,0,9,0,0]); //true
        // isStraight([0, 0, 2, 2, 5]);//false 无重复

        // 大佬思路 最大牌-最小牌 < 5   可构成顺子     
        const isStraight = function (nums) {
            // 大佬思路 max=0; min=14
            let max = 0, min = 14; // min 不能是0 nums[0]不行
            let set = new Set();

            for (const num of nums) {
                if (num === 0) continue;
                max = Math.max(max, num);
                min = Math.min(min, num);
                if (set.has(num)) return false;
                set.add(num);
            }

            return max - min < 5;

        };

        // isStraight([1,2,3,4,5])

        //剑指 Offer 58 - I. 翻转单词顺序
        const reverseWords = function (s) {
            s = s.trim().split(' '); // trim white space  split by words;
            s = s.filter(words => words !== ''); // delete extra white space;
            return s.reverse().join(' ');
        };

        //剑指 Offer 45. 把数组排成最小的数
        // 按照首位排序
        // 计算首位的值，把值与之前的数字一一对应起来， 应该存在什么样的数据结构里呢
        // 最开始想到是map, obj， 最后决定用 2-d array
        const digits = function (num) {
            let tmp = [];
            while (Math.floor(num) !== 0) {
                tmp.unshift(num % 10); // 8  ,7 , 5
                num = Math.floor(num / 10); //57 ,5
            };
            return tmp;
        }; // digits 函数遇到0 会返回空。特殊情况



        const minNumber = function (nums) {
            let index = 0;
            for (let i = 0; i < nums.length; i++) {
                if (nums[i] === 0) {  // 先把0 移到最前面
                    [nums[index], nums[i]] = [nums[i], nums[index]];
                    index++;
                } else {
                    let digit = digits(nums[i])
                    nums[i] = [nums[i], ...digit];
                }
            };

            // sort by first digit 
            nums.sort((a, b) => a[1] - b[1]);

            let i = index > 0 ? index + 1 : 0;

            for (i, j = i + 1, r = 1; j < nums.length;) {// row
                if (nums[i][r] === nums[j][r]) {
                    j++;
                };

            }



            console.log(nums)

        };
        //   minNumber([5, 9,3, 0,30, 0, 34]);

        //剑指 Offer 65. 不用加减乘除做加法
        const add = function (a, b) {

            while (b) {
                // 进位
                const c = (a & b) << 1;
                // 不考虑进位的加法
                a ^= b;
                // 将进位赋值给b
                b = c;
            }
            return a;
        };

        // const add = (a, b) => b ? add(a ^ b, (a & b) << 1) : a;

        // 盛水最多的容器
        // 头尾双指针 向内收窄 每次移动两板中的短板 update面积
        const maxArea = function (height) {
            let left = 0, right = height.length - 1, res = 0;

            while (left < right) {
                area = Math.min(height[left], height[right]) * (right - left);
                height[left] < height[right] ? left++ : right--;
                res = Math.max(res, area)
            };

            return res;

        };

        //maxArea([1, 8, 6, 2, 5, 4, 8, 3, 7])

        //200. 岛屿数量
        const numIslands3 = function (grid) {
            let m = grid.length,
                n = grid[0].length;
            count = 0;

            const dfs = function (r, c) {
                if (r < 0 || r >= m || c < 0 || c >= n || parseInt(grid[r][c]) !== 1) return;
                grid[r][c] = 0; // 避免重复被计入， 依然会重复访问

                dfs(r - 1, c);
                dfs(r + 1, c);
                dfs(r, c - 1);
                dfs(r, c + 1);
            };

            for (let i = 0; i < m; i++) {
                for (let j = 0; j < n; j++) {
                    if (parseInt(grid[i][j]) === 1) {  // 不用parseInt的话，就直接等于“1”
                        dfs(i, j);
                        count++; // count++ 的位置 在这里
                    }

                }
            }

            return count;
        };

        // fcttttttttttt
        function getleft(m, row, col) {
            if (col == 0)
                return [-1, -1];

            return [row, col - 1];
        }

        function getright(m, row, col) {
            if (col == m[0].length - 1)
                return [-1, -1];

            return [row, col + 1];
        }

        function getupper(m, row, col) {
            if (row == 0)
                return [-1, -1];

            return [row - 1, col];
        }

        function getdown(m, row, col) {
            if (row == m.length - 1)
                return [-1, -1];

            return [row + 1, col];
        }

        let dir = [];
        dir.push(getleft);
        dir.push(getright);
        dir.push(getupper);
        dir.push(getdown);

        function numIslands(m) {
            let islandcnt = 0;
            let maxisland = 0; // 最大面积
            for (let row = 0; row < m.length; row++) {
                for (let col = 0; col < m[row].length; col++) {
                    if ("2" == m[row][col] || "0" == m[row][col])
                        continue;

                    let newisland = [];
                    newisland.push([row, col]);
                    m[row][col] = "2";
                    for (let k = 0; k < newisland.length; k++) {
                        const rowcol = newisland[k];

                        for (let di = 0; di < dir.length; di++) {
                            const neighbor = dir[di](m, rowcol[0], rowcol[1]);
                            if (-1 != neighbor[0] && "1" == m[neighbor[0]][neighbor[1]]) {
                                newisland.push([neighbor[0], neighbor[1]]);
                                m[neighbor[0]][neighbor[1]] = "2";
                            }
                        }
                    }

                    islandcnt++;
                    if (maxisland < newisland.length)
                        maxisland = newisland.length;
                }
            }

            return islandcnt;
        }

        numIslands([
            ["1", "1", "1", "1", "0"],
            ["1", "1", "0", "1", "0"],
            ["1", "1", "0", "0", "0"],
            ["0", "0", "0", "0", "0"]
        ])

        //463. 岛屿的周长
        const islandPerimeter1 = function (m) {
            let perimeter = 0;
            let newisland = [];

            for (let row = 0; row < m.length; row++) {
                for (let col = 0; col < m[row].length; col++) {
                    if ("2" == m[row][col] || "0" == m[row][col])
                        continue;

                    newisland.push([row, col]);
                    m[row][col] = "2";
                    for (let k = 0; k < newisland.length; k++) {
                        const rowcol = newisland[k];

                        for (let di = 0; di < dir.length; di++) {
                            const neighbor = dir[di](m, rowcol[0], rowcol[1]);
                            if (-1 != neighbor[0] && "1" == m[neighbor[0]][neighbor[1]]) {
                                newisland.push([neighbor[0], neighbor[1]]);
                                m[neighbor[0]][neighbor[1]] = "2";
                            }
                        }
                    }
                }
            }
            // 岛屿都被push到newisland.
            for (let k = 0; k < newisland.length; k++) {
                const rowcol = newisland[k];
                for (let di = 0; di < dir.length; di++) {
                    const neighbor = dir[di](m, rowcol[0], rowcol[1]);
                    if (-1 === neighbor[0] || "0" == m[neighbor[0]][neighbor[1]]) {
                        perimeter++
                    }
                }
            }

            return perimeter;
        }

        //-------------------------------------------
        const islandPerimeter = function (grid) {
            let perimeter = 0, newisland = [];
            let m = grid.length, n = grid[0].length;

            function dfs(r, c) {
                if (r < 0 || r >= m || c < 0 || c >= n || grid[r][c] === "0") return 1; // grid[r][c]===0;
                return 0;
            }

            for (let i = 0; i < m; i++) {
                for (let j = 0; j < n; j++) {
                    if (grid[i][j] === "1") {
                        newisland.push([i, j]);
                    }
                }
            };

            for (let k = 0; k < newisland.length; k++) {
                let row = newisland[k][0];
                let col = newisland[k][1];
                let neighbors = dfs(row, col - 1) + dfs(row, col + 1) + dfs(row - 1, col) + dfs(row + 1, col)

                perimeter += neighbors
            }

            return perimeter;
        };

        /*   islandPerimeter([
               ["1", "1", "1", "1", "0"],
               ["1", "1", "0", "1", "0"],
               ["1", "1", "0", "0", "0"],
               ["0", "0", "0", "0", "0"]
           ])
   
       */

        //230. 二叉搜索树中第K小的元素
        // bst 中序遍历是升序数组，数组的第k-1个元素
        const kthSmallest = function (root, k) {
            let inoderArr = [];

            const dfs = (node) => {
                if (!node) return;

                dfs(node.left);
                inoderArr.push(node.val);
                dfs(node.right);
            };

            dfs(root);

            return inoderArr[k - 1]
        };



        //55. Jump Game
        const canJump = function (nums) {
            let rightindex = 0;

            for (let i = 0; i < nums.length - 1; i++) {
                if (rightindex < i) return false; // 0 跳不到2
                rightindex = Math.max(rightindex, i + nums[i])
            };

            return rightindex >= nums.length - 1;

        };

        //canJump( [2,3,1,1,4]); // true
        //canJump([0,2,3]) // 0 跳不到2
        //canJump([3,2,1,0,4])

        //45. Jump Game II
        // reach the last index in the minimum number of jumps
        const jump1111 = function (nums) {
            let minimumCount = nums.length;

            for (let i = 0; i < nums.length - 1; i++) {
                let right = i;
                let count = 0;

                while (right < nums.length - 1) {
                    right = right + nums[right];
                    count++;
                };
                minimumCount = Math.min(count, minimumCount)
            };

            return minimumCount;
        };

        const jump = function (nums) {
            let dp = [];
            let rightmost = 0;
            let left = 1;

            dp[0] = 0;
            for (let i = 0; i < nums.length - 1; i++) {
                rightmost = i + nums[i];
                if (rightmost < left) continue;
                let j = left;
                for (j; j <= rightmost; j++) {
                    dp[j] = dp[i] + 1;
                    if (j === nums.length - 1) return dp[nums.length - 1];
                };
                left = j;

            };

            return dp[nums.length - 1]
        };


        // jump([2,3,1,1,4]);//2
        //jump([3,2,1]);
        //  jump([1,2,1,1,1]); //3
        //   jump([7, 0, 9, 6, 9, 6, 1, 7, 9, 0, 1, 2, 9, 0, 3]); //2
        //jump([2,1,1,1,1]);//3


        //62. Unique Paths
        const uniquePaths1 = function (m, n) {  // 这个解法就是图论里的深搜 会超时
            let count = 0;

            function dfs(r, c) {
                if (r >= m || c >= n) return; // 不存在 r<0 || c<0
                if (r === m - 1 && c === n - 1) count++;
                dfs(r + 1, c);
                dfs(r, c + 1);

            };

            dfs(0, 0);

            return count;
        };

        // uniquePaths(3,7);//28
        // uniquePaths(23,12); //超时

        //dp
        const uniquePaths = function (m, n) {
            let dp = new Array(m).fill(0).map(item => new Array(n));

            dp[0][0] = 1;
            for (let i = 1; i < m; i++) {
                dp[i][0] = dp[i - 1][0]; // equals 1 
            };
            for (let j = 1; j < n; j++) {
                dp[0][j] = dp[0][j - 1];  // equals 1 
            };

            for (let i = 1; i < m; i++) {
                for (let j = 1; j < n; j++) {
                    dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
                }
            };

            return dp[m - 1][n - 1];

        };

        // uniquePaths(3,7)


        // 63. Unique Paths II
        const uniquePathsWithObstacles = function (obstacleGrid) {
            let m = obstacleGrid.length, n = obstacleGrid[0].length;
            let dp = new Array(m).fill(0).map(item => new Array(n));

            if (obstacleGrid[0][0] === 1 || obstacleGrid[m - 1][n - 1] === 1) return 0;
            dp[0][0] = 1;

            for (let i = 1; i < m;) {
                if (obstacleGrid[i][0] === 0) {
                    dp[i][0] = 1;
                    i++;
                } else {
                    while (i < m) {
                        dp[i][0] = -999;
                        i++;
                    }
                }
            };

            for (let j = 1; j < n;) {
                if (obstacleGrid[0][j] === 0) {
                    dp[0][j] = 1;
                    j++;
                } else {
                    while (j < n) {
                        dp[0][j] = -999;
                        j++;
                    }
                }
            };

            for (let i = 1; i < m; i++) {
                for (let j = 1; j < n; j++) {
                    if (obstacleGrid[i][j] === 1) {
                        dp[i][j] = -999;
                        continue;
                    }
                    if (dp[i - 1][j] === -999 && dp[i][j - 1] === -999) {
                        dp[i][j] = -999;
                    } else if (dp[i - 1][j] === -999) {
                        dp[i][j] = dp[i][j - 1];
                    } else if (dp[i][j - 1] === -999) {
                        dp[i][j] = dp[i - 1][j];
                    } else {
                        dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
                    };
                }
            }
            return dp[m - 1][n - 1] === -999 ? 0 : dp[m - 1][n - 1];
        };


        //uniquePathsWithObstacles([[0, 0, 0], [0, 1, 0], [0, 0, 0]])

        //1014. Best Sightseeing Pair
        /* const maxScoreSightseeingPair = function(values) {
             let i=0, j=values.length-1;
             let max_value = 0;
 
             while(i<j) {
                 let value = values[i] + values[j] + i -j;
                 if(values[i]>= values[j]) {
                     j--;
                 } else {
                     i++;
                 };
 
                
                 max_value = Math.max(max_value, value);
             };
 
             return max_value;
         };
         */ // 接雨水头尾双指针收缩 这种解法不行。当values[i]=values[j]时，该向那边收缩不确定。 而且这里需要的是ij间距较小的。

        const maxScoreSightseeingPair1 = function (values) {
            // value = values[i] + values[j] + i - j 
            // equals to : (values[i] + i) + (values[j] -j);

            let dp = new Array(values.length);
            dp[0] = values[0];
            let res = 0;

            for (let i = 1; i < values.length; i++) {
                dp[i] = Math.max(dp[i - 1], values[i] + i);
                res = Math.max(res, dp[i - 1] + values[i] - i);
            };

            return res;

        };

        // 压缩空间
        const maxScoreSightseeingPair = function (values) {
            let res = 0, mx = values[0];

            for (let i = 1; i < values.length; i++) {
                res = Math.max(res, mx + values[i] - i)
                mx = Math.max(mx, values[i] + i);
            };

            return res;
        }


        // maxScoreSightseeingPair([8,1,5,2,6]);

        //64. Minimum Path Sum
        //超时！！
        /*const minPathSum = function (grid) {
            let m = grid.length, n = grid[0].length;
            let minSum = 10000;
            let curSum = 0;

            function dfs(r, c) {
                if (r >= m || c >= n) return; // 越界
                curSum += grid[r][c];
                if (r === m - 1 && c === n - 1) {
                    minSum = Math.min(minSum, curSum);
                    curSum -= grid[r][c];
                    return
                };
                dfs(r + 1, c);
                dfs(r, c + 1);
                curSum -= grid[r][c];
            };

            dfs(0, 0);
            return minSum;
        };
        */

        const minPathSum = function (grid) {
            let m = grid.length, n = grid[0].length;

            for (let i = 1; i < grid.length; i++) {
                grid[i][0] = grid[i][0] + grid[i - 1][0];
            };

            for (let j = 1; j < grid[0].length; j++) {
                grid[0][j] += grid[0][j - 1];
            };

            for (let i = 1; i < grid.length; i++) {
                for (let j = 1; j < grid[0].length; j++) {
                    grid[i][j] = Math.min(grid[i - 1][j], grid[i][j - 1]) + grid[i][j];  //update grid
                }
            };

            return grid[m - 1][n - 1];

        };
        //minPathSum([[1, 3, 1], [1, 5, 1], [4, 2, 1]])

        //
        const majorityElement = function (nums) {
            let votes = 0, cur = 0;

            nums.forEach(num => {
                if (votes === 0) cur = num; // cur start from the first element in array 
                num === cur ? votes += 1 : votes -= 1;
            })

            return cur;
        };

        // majorityElement([1, 2, 3, 2, 2, 2, 5, 4, 2]);

        //剑指 Offer 62. 圆圈中最后剩下的数字   --- 约瑟夫环
        const lastRemaining = function (n, m) {
            let res = 0;

            for (let i = 2; i <= n; i++) {
                res = (res + m) % i;
            };

            return res;
        };

        //492. Construct the Rectangle
        const constructRectangle = function (area) {
            let L = Math.floor(Math.sqrt(area)), W = 0;

            for (L; ; L--) {
                if (area % L === 0) {
                    W = area / L;
                    break;
                };
            };

            return L > W ? [L, W] : [W, L];
        };

        // constructRectangle(122122);

        //剑指 Offer 66. 构建乘积数组
        const constructArr = function (a) {
            if (a === null || a.length === 0) return a;

            let leftproduct = [];
            let rightProduct = [];
            leftproduct[0] = 1;
            rightProduct[a.length - 1] = 1;

            for (let i = 1; i < a.length; i++) {
                leftproduct[i] = leftproduct[i - 1] * a[i - 1];
            };

            for (let i = a.length - 2; i >= 0; i--) {
                rightProduct[i] = a[i + 1] * rightProduct[i + 1];
            };

            let res = [];
            for (i = 0; i < a.length; i++) {
                res[i] = leftproduct[i] * rightProduct[i];
            };

            return res;

        };

        //240. Search a 2D Matrix II
        //74. Search a 2D Matrix
        const searchMatrix2 = function (matrix, target) {
            let m = matrix.length;
            let n = matrix[0].length;
            let r = m - 1; c = 0;

            // start from the bottom left corner
            while (r >= 0 && c <= n - 1) {
                if (matrix[r][c] > target) {
                    r--;
                } else if (matrix[r][c] < target) {
                    c++;
                } else {
                    return true;
                }
            };

            return false;

        };


        //496. Next Greater Element I
        // 简单遍历
        const nextGreaterElement1 = function (nums1, nums2) {
            let res = [];

            for (let i = 0; i < nums1.length; i++) {
                let idx = nums2.indexOf(nums1[i]);
                let flag = false; //用flag很妙

                for (let j = idx; j < nums2.length; j++) {
                    // 如果j从idx + 1 开始找，确实少找了了一个，但要特使处理指针越界；
                    // j从idx开始，多找了一次，不过不需要处理越界。
                    if (nums2[j] > nums1[i]) {
                        res.push(nums2[j]);
                        flag = true;
                        break;
                    }
                };
                if (!flag) { // flag is false
                    res.push(-1);
                };
            }

            return res;
        };


        // 单调栈 + hashmap
        const nextGreaterElement = function (nums1, nums2) {
            let map = new Map();
            let stack = [];
            let res = [];

            // from the last element
            for (let i = nums2.length - 1; i >= 0; i--) {
                while (stack.length && stack[stack.length - 1] < nums2[i]) {
                    // stack is not empty && the top num in stack is smaller than the current nums[i]
                    stack.pop(); // pop out the smaller num
                };

                if (stack.length === 0) {
                    map.set(nums2[i], -1)
                } else {
                    map.set(nums2[i], stack[stack.length - 1]);
                };
                stack.push(nums2[i]); // monotone item
            };

            // find the res in Map
            for(const num of nums1) {
                res.push(map.get(num))
            };

            return res;

        };

         nextGreaterElement([4, 1, 2], [1, 3, 4, 2]);


        const monotoneStack = function (nums) {
            let res = [];
            let stack = [];

            // from the last element
            for (let i = nums.length - 1; i >= 0; i--) {
                while (stack.length && stack[stack.length - 1] < nums[i]) {
                    // stack is not empty && the top num in stack is smaller than the current nums[i]
                    stack.pop(); // pop out the smaller num
                };

                res[i] = stack.length === 0 ? -1 : stack[stack.length - 1];  // the cur nums[i] is smaller than the top of stack 
                stack.push(nums[i]); // monotone item
            };

            return res;
        };

        // monotoneStack([1, 3, 4, 2]);
           
    </script>

</body>

</html>