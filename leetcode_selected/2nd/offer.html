<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title></title>
</head>

<body>
    <script type="text/javascript">
        // 30: min stack
        // helper stack,push min(currentmin, x); pop everytime.

        const MinStack = function () { // can't be defind with arrow function 
            this.stack = [];
            this.stackB = [];
            this.tmp = [];
        };

        MinStack.prototype.push = x => {
            this.stack.push(x);
            if (x <= this.stackB[this.stackB.length - 1] || this.stackB.length === 0) {
                this.stackB.push(x);
            } else {
                while (this.stackB.length >= 0) {
                    this.tmp.push(this.stackB.pop());
                };
                this.stackB.push(x);
                while (this.tmp.length >= 0) {
                    this.stackB.push(this.tmp.pop())
                }
            }
        };

        MinStack.prototype.pop = () => {
            let item = this.stackA[this.stack.length - 1];
            if (item === this.stackB[this.stackB[this.stackB.length - 1]]) {
                this.stackB.pop()
            };
            return this.stack.pop();

        };

        MinStack.prototype.top = () => {
            return this.stack[this.stack.length - 1];
        }

        MinStack.prototype.min = () => {
            return this.stackB[this.stackB.length - 1];

        };

        //从尾到头打印链表 -- 回溯递归
        //内存消耗：40.4 MB , 在所有 JavaScript 提交中击败了10.58%的用户 ----栈桢空间
        const reversePrint = function (head) {
            let res = [];
            const backpath = node => {
                if (!node) return;
                backpath(node.next);
                res.push(node.val)
            };
            backpath(head);
            return res;
        };

        //反转链表   ---递归
        const reverseList = function (head) {

            const recur = (cur, pre) => {
                if (cur === null) return pre;
                res = recur(cur.next, cur);
                cur.next = pre;
                return res;
            }

            return recur(head, null)
        }

            // coppy random list 

            * // Definition for a Node.
            function Node(val, next, random) {
                this.val = val;
                this.next = next;
                this.random = random;
            };
        // the random node may not be created 

        const copyRandomList = function (head) {
            if (!head) return null;
            let node = head;
            let map = new Map();

            while (node) {  // copy no
                map.set(node, new Node(node.val));
                node = node.next;
            };

            // reset node
            node = head;
            while (node) {  // reset node.next and node.random
                map.get(node).next = map.get(node.next) === undefined ? null : map.get(node.ext);
                map.get(node).random = map.get(node.random);
                node = node.next;
            };

            return map.get(head);

        }


        //剑指 Offer 59 - II. 队列的最大值
        // 本来想用类似Minstack的方式 维护辅助栈，但是这样做在本题中行不通

        // queue是会双头出队的，所以当最大值从队首出队后，maxQ中的最大值就错了。
        /*
        const MaxQueue = function() {
            this.queue = [];
            this.maxQ = []; 
        };
        */
        /**
         * @return {number}
         * 若队列为空 pop_front 和 max_value 需要返回 -1
         */
        /**
        MaxQueue.prototype.max_value = function() {
            if (!this.queue.length) {
                return -1
            } else {
                return this.maxQ[this.maxQ.length -1] 
            }
           
        };
        */
        /** 
         * @param {number} value
         * @return {void}
         */
        /**
        MaxQueue.prototype.push_back = function(value) {
            this.queue.push(value);
            if(this.maxQ.length===0){
                this.maxQ.push(value)
            } else {
                this.maxQ.push( Math.max(value, this.maxQ[this.maxQ.length-1]))
            };
        
        };
        */
        /**
         * @return {number}
         */
        /**
        MaxQueue.prototype.pop_front = function() {
            if(this.queue.length === 0) {
                return -1
            } else {
                this.maxQ.shift();
                return this.queue.shift();
            }
        };
        */

        const MaxQueue = function () {
            this.queue = [];
            this.dequeue = [];
        };

        MaxQueue.prototype.max_value = function () {
            if (!this.queue.length) {
                return -1
            } else {
                return this.dequeue[0]
            }
        };

        MaxQueue.prototype.push_back = function (value) {
            this.queue.push(value);
            if (this.dequeue.length === 0 || this.dequeue[this.dequeue.length - 1] > value) {
                this.dequeue.push(value)
            } else {
                while (this.dequeue[this.dequeue.length - 1] < value) {
                    this.dequeue.pop()
                };
                this.dequeue.push(value)
            }
        };

        MaxQueue.prototype.pop_front = function () {
            if (this.queue.length === 0) {
                return -1
            } else {
                let front = this.queue.shift();
                if (front === this.dequeue[0]) {
                    this.dequeue.shift()
                }
                return front
            }
        };

        //剑指 Offer 57 - II. 和为s的连续正数序列
        //滑动窗口 双指针
        const findContinuousSequence = function (target) {
            let l = 1, r = 1, sum = 1; // 正整数序列
            let res = [];
            while (l < target / 2) {
                if (sum < target) { // 右指针右移
                    r++;
                    sum += r
                }
                if (sum > target) { // 左指针右移

                    sum -= l;
                    l++;
                }
                if (sum === target) {
                    let ans = [];
                    for (let k = l; k <= r; k++) {
                        ans.push(k);
                    };
                    res.push(ans);
                    sum -= l;
                    l++

                }
            }
            return res;
        };

        // findContinuousSequence(9)


        //剑指 Offer 68 - I. 二叉搜索树的最近公共祖先
        //迭代
        const lowestCommonAncestor1 = function (root, p, q) {
            while (root) {
                if (root.val < p.val && root.val < q.val) {
                    root = root.right;
                } else if (root.val > p.val && root.val > q.val) {
                    root = root.left;
                } else {
                    break;
                }
            }
            return root;
        };
        //递归
        const lowestCommonAncestor2 = function (root, p, q) {
            if (root.val < p.val && root.val < q.val) {
                return lowestCommonAncestor(root.right, p, q);
            };
            if (root.val > p.val && root.val > q.val) {
                return lowestCommonAncestor(root.left, p, q)
            }
            return root
        };

        //剑指 Offer 68 - II. 二叉树的最近公共祖先 LCOF
        //先序遍历 
        const lowestCommonAncestor = function (root, p, q) {
            // 叶子节点 或者找到了p 或 q   //// 这里可以直接比较node，不需要比较node.val
            if (root === null || root === p || root === q) return root;
            //先序遍历
            let left = lowestCommonAncestor(root.left, p, q);
            let right = lowestCommonAncestor(root.right, p, q);

            if (left === null) return right;
            if (right === null) return left;

            return root;
        };


        //剑指 Offer 14- I. 剪绳子
        const cuttingRope = function (n) {
            if (n === 2) return 1;
            if (n === 3) return 2;
            let dp = new Array();
            dp[1] = 1;
            dp[2] = 2;
            dp[3] = 3;

            for (let i = 4; i <= n; i++) {
                //let l = Math.floor(i / 2);
                //let r = i - l;
                //product1 = dp[l] * dp[r]
                dp[i] = Math.max(dp[3] * dp[i - 3], dp[2] * dp[i - 2])
            };

            return dp[n];

        };

        // cuttingRope(9);

        //剑指 Offer 64. 求1+2+…+n
        const sumNums = function (n) {
            n > 1 && (n += sumNums(n - 1));   // 逻辑短路
            return n;

        };

        //剑指 Offer 46. 把数字翻译成字符串
        // 取余 取整   js 语言特性 浮点数
        const translateNum1 = function (num) {   /// false
            let res = 0;

            while (Math.floor(num) != 0) {
                let x = num % 10;
                let y = num % 100;

                if (y >= 10 && y <= 25) {
                    res += 2
                    num /= 100;
                } else {
                    res += 1;
                    num /= 10;

                };
            }

            return res;
        };

        // translateNum(26);  // 这么写的话 给个两位数就直接报错了。

        const translateNum = function (num) {
            let a = 1, b = 1, x, y = num % 10;
            while (num != 0) {
                num = Math.floor(num / 10);
                x = num % 10;
                let tmp = 10 * x + y;
                let c = (tmp >= 10 && tmp <= 25) ? a + b : a;
                b = a;
                a = c;
                y = x;
            };
            return a;
        };

        // translateNum(26);

        //剑指 Offer 61. 扑克牌中的顺子
        const isStraight1 = function (nums) {
            nums.sort((a, b) => a - b);
            let count = 0; // how many zeros
            let diff = 0;

            for (let i = 0; i <= 3; i++) {
                if (nums[i] === 0) {
                    count++;
                } else {
                    if (nums[i] === nums[i + 1]) return false;
                    diff += nums[i] - nums[i + 1] + 1;
                    if (Math.abs(diff) > count) return false;
                }
            };

            return count + diff >= 0 // count>diff 说明0多，可以当做任意牌

        };

        //isStraight([1,2,3,4,5]);
        //isStraight([9,1,13,2,13]); //false
        //isStraight([11,0,9,0,0]); //true
        // isStraight([0, 0, 2, 2, 5]);//false 无重复

        // 大佬思路 最大牌-最小牌 < 5   可构成顺子     
        const isStraight = function (nums) {
            // 大佬思路 max=0; min=14
            let max = 0, min = 14; // min 不能是0 nums[0]不行
            let set = new Set();

            for (const num of nums) {
                if (num === 0) continue;
                max = Math.max(max, num);
                min = Math.min(min, num);
                if (set.has(num)) return false;
                set.add(num);
            }

            return max - min < 5;

        };

        // isStraight([1,2,3,4,5])

        //剑指 Offer 58 - I. 翻转单词顺序
        const reverseWords = function (s) {
            s = s.trim().split(' '); // trim white space  split by words;
            s = s.filter(words => words !== ''); // delete extra white space;
            return s.reverse().join(' ');
        };

        //剑指 Offer 45. 把数组排成最小的数
        // 按照首位排序
        // 计算首位的值，把值与之前的数字一一对应起来， 应该存在什么样的数据结构里呢
        // 最开始想到是map, obj， 最后决定用 2-d array
        const digits = function (num) {
            let tmp = [];
            while (Math.floor(num) !== 0) {
                tmp.unshift(num % 10); // 8  ,7 , 5
                num = Math.floor(num / 10); //57 ,5
            };
            return tmp;
        }; // digits 函数遇到0 会返回空。特殊情况



        const minNumber = function (nums) {
            let index = 0;
            for (let i = 0; i < nums.length; i++) {
                if (nums[i] === 0) {  // 先把0 移到最前面
                    [nums[index], nums[i]] = [nums[i], nums[index]];
                    index++;
                } else {
                    let digit = digits(nums[i])
                    nums[i] = [nums[i], ...digit];
                }
            };

            // sort by first digit 
            nums.sort((a, b) => a[1] - b[1]);

            let i = index > 0 ? index + 1 : 0;

            for (i, j = i + 1, r = 1; j < nums.length;) {// row
                if (nums[i][r] === nums[j][r]) {
                    j++;
                };

            }



            console.log(nums)

        };
        //   minNumber([5, 9,3, 0,30, 0, 34]);

        //剑指 Offer 65. 不用加减乘除做加法
        const add = function (a, b) {

            while (b) {
                // 进位
                const c = (a & b) << 1;
                // 不考虑进位的加法
                a ^= b;
                // 将进位赋值给b
                b = c;
            }
            return a;
        };

        // const add = (a, b) => b ? add(a ^ b, (a & b) << 1) : a;

        // 盛水最多的容器
        // 头尾双指针 向内收窄 每次移动两板中的短板 update面积
        const maxArea = function (height) {
            let left = 0, right = height.length - 1, res = 0;

            while (left < right) {
                area = Math.min(height[left], height[right]) * (right - left);
                height[left] < height[right] ? left++ : right--;
                res = Math.max(res, area)
            };

            return res;

        };

        //maxArea([1, 8, 6, 2, 5, 4, 8, 3, 7])

        //200. 岛屿数量
        const numIslands3 = function (grid) {
            let m = grid.length,
                n = grid[0].length;
            count = 0;

            const dfs = function (r, c) {
                if (r < 0 || r >= m || c < 0 || c >= n || parseInt(grid[r][c]) !== 1) return;
                grid[r][c] = 0; // 避免重复被计入， 依然会重复访问

                dfs(r - 1, c);
                dfs(r + 1, c);
                dfs(r, c - 1);
                dfs(r, c + 1);
            };

            for (let i = 0; i < m; i++) {
                for (let j = 0; j < n; j++) {
                    if (parseInt(grid[i][j]) === 1) {  // 不用parseInt的话，就直接等于“1”
                        dfs(i, j);
                        count++; // count++ 的位置 在这里
                    }

                }
            }

            return count;
        };

        // fcttttttttttt
        function getleft(m, row, col) {
            if (col == 0)
                return [-1, -1];

            return [row, col - 1];
        }

        function getright(m, row, col) {
            if (col == m[0].length - 1)
                return [-1, -1];

            return [row, col + 1];
        }

        function getupper(m, row, col) {
            if (row == 0)
                return [-1, -1];

            return [row - 1, col];
        }

        function getdown(m, row, col) {
            if (row == m.length - 1)
                return [-1, -1];

            return [row + 1, col];
        }

        let dir = [];
        dir.push(getleft);
        dir.push(getright);
        dir.push(getupper);
        dir.push(getdown);

        function numIslands(m) {
            let islandcnt = 0;
            let maxisland = 0; // 最大面积
            for (let row = 0; row < m.length; row++) {
                for (let col = 0; col < m[row].length; col++) {
                    if ("2" == m[row][col] || "0" == m[row][col])
                        continue;

                    let newisland = [];
                    newisland.push([row, col]);
                    m[row][col] = "2";
                    for (let k = 0; k < newisland.length; k++) {
                        const rowcol = newisland[k];

                        for (let di = 0; di < dir.length; di++) {
                            const neighbor = dir[di](m, rowcol[0], rowcol[1]);
                            if (-1 != neighbor[0] && "1" == m[neighbor[0]][neighbor[1]]) {
                                newisland.push([neighbor[0], neighbor[1]]);
                                m[neighbor[0]][neighbor[1]] = "2";
                            }
                        }
                    }

                    islandcnt++;
                    if (maxisland < newisland.length)
                        maxisland = newisland.length;
                }
            }

            return islandcnt;
        }

        numIslands([
            ["1", "1", "1", "1", "0"],
            ["1", "1", "0", "1", "0"],
            ["1", "1", "0", "0", "0"],
            ["0", "0", "0", "0", "0"]
        ])

        //463. 岛屿的周长
        const islandPerimeter1 = function (m) {
            let perimeter = 0;
            let newisland = [];

            for (let row = 0; row < m.length; row++) {
                for (let col = 0; col < m[row].length; col++) {
                    if ("2" == m[row][col] || "0" == m[row][col])
                        continue;

                    newisland.push([row, col]);
                    m[row][col] = "2";
                    for (let k = 0; k < newisland.length; k++) {
                        const rowcol = newisland[k];

                        for (let di = 0; di < dir.length; di++) {
                            const neighbor = dir[di](m, rowcol[0], rowcol[1]);
                            if (-1 != neighbor[0] && "1" == m[neighbor[0]][neighbor[1]]) {
                                newisland.push([neighbor[0], neighbor[1]]);
                                m[neighbor[0]][neighbor[1]] = "2";
                            }
                        }
                    }
                }
            }
            // 岛屿都被push到newisland.
            for (let k = 0; k < newisland.length; k++) {
                const rowcol = newisland[k];
                for (let di = 0; di < dir.length; di++) {
                    const neighbor = dir[di](m, rowcol[0], rowcol[1]);
                    if (-1 === neighbor[0] || "0" == m[neighbor[0]][neighbor[1]]) {
                        perimeter++
                    }
                }
            }

            return perimeter;
        }

        //-------------------------------------------
        const islandPerimeter = function (grid) {
            let perimeter = 0, newisland = [];
            let m = grid.length, n = grid[0].length;

            function dfs(r, c) {
                if (r < 0 || r >= m || c < 0 || c >= n || grid[r][c] === "0") return 1; // grid[r][c]===0;
                return 0;
            }

            for (let i = 0; i < m; i++) {
                for (let j = 0; j < n; j++) {
                    if (grid[i][j] === "1") {
                        newisland.push([i, j]);
                    }
                }
            };

            for (let k = 0; k < newisland.length; k++) {
                let row = newisland[k][0];
                let col = newisland[k][1];
                let neighbors = dfs(row, col - 1) + dfs(row, col + 1) + dfs(row - 1, col) + dfs(row + 1, col)

                perimeter += neighbors
            }

            return perimeter;
        };

        /*   islandPerimeter([
               ["1", "1", "1", "1", "0"],
               ["1", "1", "0", "1", "0"],
               ["1", "1", "0", "0", "0"],
               ["0", "0", "0", "0", "0"]
           ])
   
       */

        //230. 二叉搜索树中第K小的元素
        // bst 中序遍历是升序数组，数组的第k-1个元素
        const kthSmallest = function (root, k) {
            let inoderArr = [];

            const dfs = (node) => {
                if (!node) return;

                dfs(node.left);
                inoderArr.push(node.val);
                dfs(node.right);
            };

            dfs(root);

            return inoderArr[k - 1]
        };



        //55. Jump Game
        const canJump = function (nums) {
            let rightindex = 0;

            for (let i = 0; i < nums.length - 1; i++) {
                if (rightindex < i) return false; // 0 跳不到2
                rightindex = Math.max(rightindex, i + nums[i])
            };

            return rightindex >= nums.length - 1;

        };

        //canJump( [2,3,1,1,4]); // true
        //canJump([0,2,3]) // 0 跳不到2
        //canJump([3,2,1,0,4])

        //45. Jump Game II
        // reach the last index in the minimum number of jumps
        const jump1111 = function (nums) {
            let minimumCount = nums.length;

            for (let i = 0; i < nums.length - 1; i++) {
                let right = i;
                let count = 0;

                while (right < nums.length - 1) {
                    right = right + nums[right];
                    count++;
                };
                minimumCount = Math.min(count, minimumCount)
            };

            return minimumCount;
        };

        const jump = function (nums) {
            let dp = [];
            let rightmost = 0;
            let left = 1;

            dp[0] = 0;
            for (let i = 0; i < nums.length - 1; i++) {
                rightmost = i + nums[i];
                if (rightmost < left) continue;
                let j = left;
                for (j; j <= rightmost; j++) {
                    dp[j] = dp[i] + 1;
                    if (j === nums.length - 1) return dp[nums.length - 1];
                };
                left = j;

            };

            return dp[nums.length - 1]
        };


        // jump([2,3,1,1,4]);//2
        //jump([3,2,1]);
        //  jump([1,2,1,1,1]); //3
        //   jump([7, 0, 9, 6, 9, 6, 1, 7, 9, 0, 1, 2, 9, 0, 3]); //2
        //jump([2,1,1,1,1]);//3


        //62. Unique Paths
        const uniquePaths1 = function (m, n) {  // 这个解法就是图论里的深搜 会超时
            let count = 0;

            function dfs(r, c) {
                if (r >= m || c >= n) return; // 不存在 r<0 || c<0
                if (r === m - 1 && c === n - 1) count++;
                dfs(r + 1, c);
                dfs(r, c + 1);

            };

            dfs(0, 0);

            return count;
        };

        // uniquePaths(3,7);//28
        // uniquePaths(23,12); //超时

        //dp
        const uniquePaths = function (m, n) {
            let dp = new Array(m).fill(0).map(item => new Array(n));

            dp[0][0] = 1;
            for (let i = 1; i < m; i++) {
                dp[i][0] = dp[i - 1][0]; // equals 1 
            };
            for (let j = 1; j < n; j++) {
                dp[0][j] = dp[0][j - 1];  // equals 1 
            };

            for (let i = 1; i < m; i++) {
                for (let j = 1; j < n; j++) {
                    dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
                }
            };

            return dp[m - 1][n - 1];

        };

        // uniquePaths(3,7)


        // 63. Unique Paths II
        const uniquePathsWithObstacles = function (obstacleGrid) {
            let m = obstacleGrid.length, n = obstacleGrid[0].length;
            let dp = new Array(m).fill(0).map(item => new Array(n));

            if (obstacleGrid[0][0] === 1 || obstacleGrid[m - 1][n - 1] === 1) return 0;
            dp[0][0] = 1;

            for (let i = 1; i < m;) {
                if (obstacleGrid[i][0] === 0) {
                    dp[i][0] = 1;
                    i++;
                } else {
                    while (i < m) {
                        dp[i][0] = -999;
                        i++;
                    }
                }
            };

            for (let j = 1; j < n;) {
                if (obstacleGrid[0][j] === 0) {
                    dp[0][j] = 1;
                    j++;
                } else {
                    while (j < n) {
                        dp[0][j] = -999;
                        j++;
                    }
                }
            };

            for (let i = 1; i < m; i++) {
                for (let j = 1; j < n; j++) {
                    if (obstacleGrid[i][j] === 1) {
                        dp[i][j] = -999;
                        continue;
                    }
                    if (dp[i - 1][j] === -999 && dp[i][j - 1] === -999) {
                        dp[i][j] = -999;
                    } else if (dp[i - 1][j] === -999) {
                        dp[i][j] = dp[i][j - 1];
                    } else if (dp[i][j - 1] === -999) {
                        dp[i][j] = dp[i - 1][j];
                    } else {
                        dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
                    };
                }
            }
            return dp[m - 1][n - 1] === -999 ? 0 : dp[m - 1][n - 1];
        };


        //uniquePathsWithObstacles([[0, 0, 0], [0, 1, 0], [0, 0, 0]])

        //1014. Best Sightseeing Pair
        /* const maxScoreSightseeingPair = function(values) {
             let i=0, j=values.length-1;
             let max_value = 0;
 
             while(i<j) {
                 let value = values[i] + values[j] + i -j;
                 if(values[i]>= values[j]) {
                     j--;
                 } else {
                     i++;
                 };
 
                
                 max_value = Math.max(max_value, value);
             };
 
             return max_value;
         };
         */ // 接雨水头尾双指针收缩 这种解法不行。当values[i]=values[j]时，该向那边收缩不确定。 而且这里需要的是ij间距较小的。

        const maxScoreSightseeingPair1 = function (values) {
            // value = values[i] + values[j] + i - j 
            // equals to : (values[i] + i) + (values[j] -j);

            let dp = new Array(values.length);
            dp[0] = values[0];
            let res = 0;

            for (let i = 1; i < values.length; i++) {
                dp[i] = Math.max(dp[i - 1], values[i] + i);
                res = Math.max(res, dp[i - 1] + values[i] - i);
            };

            return res;

        };

        // 压缩空间
        const maxScoreSightseeingPair = function (values) {
            let res = 0, mx = values[0];

            for (let i = 1; i < values.length; i++) {
                res = Math.max(res, mx + values[i] - i)
                mx = Math.max(mx, values[i] + i);
            };

            return res;
        }


        // maxScoreSightseeingPair([8,1,5,2,6]);

        //64. Minimum Path Sum
        //超时！！
        /*const minPathSum = function (grid) {
            let m = grid.length, n = grid[0].length;
            let minSum = 10000;
            let curSum = 0;

            function dfs(r, c) {
                if (r >= m || c >= n) return; // 越界
                curSum += grid[r][c];
                if (r === m - 1 && c === n - 1) {
                    minSum = Math.min(minSum, curSum);
                    curSum -= grid[r][c];
                    return
                };
                dfs(r + 1, c);
                dfs(r, c + 1);
                curSum -= grid[r][c];
            };

            dfs(0, 0);
            return minSum;
        };
        */

        const minPathSum = function (grid) {
            let m = grid.length, n = grid[0].length;

            for (let i = 1; i < grid.length; i++) {
                grid[i][0] = grid[i][0] + grid[i - 1][0];
            };

            for (let j = 1; j < grid[0].length; j++) {
                grid[0][j] += grid[0][j - 1];
            };

            for (let i = 1; i < grid.length; i++) {
                for (let j = 1; j < grid[0].length; j++) {
                    grid[i][j] = Math.min(grid[i - 1][j], grid[i][j - 1]) + grid[i][j];  //update grid
                }
            };

            return grid[m - 1][n - 1];

        };
        //minPathSum([[1, 3, 1], [1, 5, 1], [4, 2, 1]])

        //
        const majorityElement = function (nums) {
            let votes = 0, cur = 0;

            nums.forEach(num => {
                if (votes === 0) cur = num; // cur start from the first element in array 
                num === cur ? votes += 1 : votes -= 1;
            })

            return cur;
        };

        // majorityElement([1, 2, 3, 2, 2, 2, 5, 4, 2]);

        //剑指 Offer 62. 圆圈中最后剩下的数字   --- 约瑟夫环
        const lastRemaining = function (n, m) {
            let res = 0;

            for (let i = 2; i <= n; i++) {
                res = (res + m) % i;
            };

            return res;
        };

        //492. Construct the Rectangle
        const constructRectangle = function (area) {
            let L = Math.floor(Math.sqrt(area)), W = 0;

            for (L; ; L--) {
                if (area % L === 0) {
                    W = area / L;
                    break;
                };
            };

            return L > W ? [L, W] : [W, L];
        };

        // constructRectangle(122122);

        //剑指 Offer 66. 构建乘积数组
        const constructArr = function (a) {
            if (a === null || a.length === 0) return a;

            let leftproduct = [];
            let rightProduct = [];
            leftproduct[0] = 1;
            rightProduct[a.length - 1] = 1;

            for (let i = 1; i < a.length; i++) {
                leftproduct[i] = leftproduct[i - 1] * a[i - 1];
            };

            for (let i = a.length - 2; i >= 0; i--) {
                rightProduct[i] = a[i + 1] * rightProduct[i + 1];
            };

            let res = [];
            for (i = 0; i < a.length; i++) {
                res[i] = leftproduct[i] * rightProduct[i];
            };

            return res;

        };

        //240. Search a 2D Matrix II
        //74. Search a 2D Matrix
        const searchMatrix2 = function (matrix, target) {
            let m = matrix.length;
            let n = matrix[0].length;
            let r = m - 1; c = 0;

            // start from the bottom left corner
            while (r >= 0 && c <= n - 1) {
                if (matrix[r][c] > target) {
                    r--;
                } else if (matrix[r][c] < target) {
                    c++;
                } else {
                    return true;
                }
            };

            return false;

        };

        // 单调栈
        const monotoneStack = function (nums) {
            let res = [];
            let stack = [];

            // from the last element
            for (let i = nums.length - 1; i >= 0; i--) {
                while (stack.length && stack[stack.length - 1] <= nums[i]) {
                    // stack is not empty && the top num in stack is smaller than the current nums[i]
                    stack.pop(); // pop out the smaller num
                };

                res[i] = stack.length === 0 ? -1 : stack[stack.length - 1];  // the cur nums[i] is smaller than the top of stack 
                stack.push(nums[i]); // monotone item
            };

            return res;
        };

        // monotoneStack([1, 3, 4, 2]);

        //496. Next Greater Element I
        // 简单遍历
        const nextGreaterElement1 = function (nums1, nums2) {
            let res = [];

            for (let i = 0; i < nums1.length; i++) {
                let idx = nums2.indexOf(nums1[i]);
                let flag = false; //用flag很妙

                for (let j = idx; j < nums2.length; j++) {
                    // 如果j从idx + 1 开始找，确实少找了了一个，但要特使处理指针越界；
                    // j从idx开始，多找了一次，不过不需要处理越界。
                    if (nums2[j] > nums1[i]) {
                        res.push(nums2[j]);
                        flag = true;
                        break;
                    }
                };
                if (!flag) { // flag is false
                    res.push(-1);
                };
            }

            return res;
        };


        // 单调栈 + hashmap
        const nextGreaterElement = function (nums1, nums2) {
            let map = new Map();
            let stack = [];
            let res = [];

            // from the last element
            for (let i = nums2.length - 1; i >= 0; i--) {
                while (stack.length && stack[stack.length - 1] < nums2[i]) {
                    // stack is not empty && the top num in stack is smaller than the current nums[i]
                    stack.pop(); // pop out the smaller num
                };

                if (stack.length === 0) {
                    map.set(nums2[i], -1)
                } else {
                    map.set(nums2[i], stack[stack.length - 1]);
                };
                stack.push(nums2[i]); // monotone item
            };

            // find the res in Map
            for (const num of nums1) {
                res.push(map.get(num))
            };

            return res;

        };

        // nextGreaterElement([4, 1, 2], [1, 3, 4, 2]);




        //503. 下一个更大元素 II  --- circular integer array
        const nextGreaterElements = function (nums) {
            let res = [];
            let stack = [];
            let n = nums.length

            // from the last element; pretend the array is double sized.
            for (let i = 2 * n - 1; i >= 0; i--) {
                while (stack.length && stack[stack.length - 1] <= nums[i % n]) { // less or equal to !!!
                    stack.pop(); // pop out the smaller num
                };

                res[i % n] = stack.length === 0 ? -1 : stack[stack.length - 1];  // res[i%n] 会重写修改结果。 
                stack.push(nums[i % n]); // monotone item
            };

            return res;
        };

        // nextGreaterElements([1,2,1]);

        //739. Daily Temperatures
        const dailyTemperatures = function (temperatures) {
            let res = [], stack = [];

            for (let i = temperatures.length - 1; i >= 0; i--) {
                let count = 1;
                while (stack.length > 0 && temperatures[i] >= stack[stack.length - 1][0]) {
                    count += stack.pop()[1];

                };

                if (stack.length === 0) {
                    res[i] = 0;
                } else {
                    res[i] = count;
                };

                stack.push([temperatures[i], res[i]])
            }
            return res;
        };

        //改进版： 单调栈里面放下标
        // dailyTemperatures([73,74,75,71,69,72,76,73]);//[1,1,4,2,1,1,0,0]；

        //剑指 Offer 15. 二进制中1的个数   / 191. Number of 1 Bits
        const hammingWeight = function (n) {
            let count = 0;
            while (n) {
                if (n & 1) {
                    count++;
                };
                n = n >>> 1; // 无符号右移
            };

            return count;
        };

        //剑指 Offer 36. 二叉搜索树与双向链表
        // inorder traversal 要求不能创建任何新的节点，只能调整树中节点指针的指向。
        /**
        * // Definition for a Node.
        * function Node(val,left,right) {
        *    this.val = val;
        *    this.left = left;
        *    this.right = right;
        * };
        */
        const treeToDoublyList1 = function (root) {
            if (!root) return; // empty tree
            let head = null;
            let pre = head;
            inOrder(root);

            // 中序遍历结束后，pre指向最后一个节点，head 指向第一个节点；
            //首尾相连
            head.left = pre;
            pre.right = head;
            return head;

            function inOrder(node, pre) {
                if (!node) return;
                inOrder(node.left, pre);

                // 当前层要做的事情；
                /* if(!pre) {
                     // left leaf node, as the head of the linked list
                     head = node;
                  } else {
                      pre.right = node; 
                  }
                 */

                !pre ? head = node : pre.right = node;
                node.left = pre;
                pre = node;

                inOrder(node.right, pre);
            }
        };

        // 迭代
        const treeToDoublyList = function (root) {
            if (!root) return; // empty tree
            let stack = [];
            let node = root;
            let pre = null;
            let head = null;

            while (stack.length || node) {
                if (node) {
                    stack.push(node);
                    node = node.left;
                } else {
                    const cur = stack.pop();
                    !pre ? head = cur : pre.right = cur;
                    cur.left = pre;
                    pre = cur; // update pre

                    node = cur.right;
                }
            }
            head.left = pre;
            pre.right = head;
            return head;
        };

        //84. 柱状图中最大的矩形   
        // 类似 11. 盛水最多的容器
        // 10.28 跟雨水的区别在于，1）接雨水不在意区间内中间的短柱子，因为水不会漏。此处计算面积需在意。
        // 2）接雨水需要两个柱子， 这里一根就行。
        /*const largestRectangleArea = function (height) {
            let left = 0, right = height.length - 1, res = height[0];

            while (left <= right && height.length >= 2) {
                if (height[left] === 0) left++;
                if (height[right] === 0) right--;
                let area = Math.min(height[left], height[right]) * (right - left + 1);
                height[left] < height[right] ? left++ : right--;
                res = Math.max(res, area)
            };

            return res;
        };
        */

        //solution: monotone stack (increasing)
        const largestRectangleArea = function (heights) {
            let stack = []; // for  stroring index
            let area = 0;
            let maxArea = 0;
            heights = [0, ...heights, 0];

            // get the left and right border index for each element.
            for (let i = 0; i < heights.length; i++) {
                // heights[i] < heights[stack[stack.length -1]]
                while (stack.length !== 0 && heights[i] < heights[stack[stack.length - 1]]) {
                    let tmp = stack.pop();
                    // 当前元素是右边第一个比tmp小的，当前栈顶元素是左边第一个比tmp小的
                    // width = rightindex - leftindex -1; 
                    area = heights[tmp] * [i - (stack[stack.length - 1]) - 1];
                    maxArea = Math.max(maxArea, area);
                };
                stack.push(i);
            };

            return maxArea;

        };
        // largestRectangleArea([2,1,5,6,2,3]);
        // largestRectangleArea([1,2,5,6,2,2,3])
        //largestRectangleArea([2,4]);
        // largestRectangleArea([5,4,1,2])

        //56. Merge Intervals
        const merge = function (intervals) {
            // sort intervals ascendingly by the start of each interval
            intervals.sort((firstNum, secondNum) => firstNum[0] - secondNum[0]);
            let res = [];
            let start = intervals[0][0];
            let end = intervals[0][1];
            for (let i = 1; i < intervals.length; i++) {
                if (intervals[i][0] <= end) { // start 落在区间内
                    //end = (end < intervals[i][1]) ? intervals[i][1] : end;  // undate end
                    end = Math.max(end, intervals[i][1]);// better code
                } else {
                    res.push([start, end]); // start 在现有区间外
                    start = intervals[i][0];
                    end = intervals[i][1];
                }
            };
            res.push([start, end]);
            return res;
        };

        const merge1 = function (intervals) {
            // sort intervals ascendingly by the start of each interval
            intervals.sort((firstNum, secondNum) => firstNum[0] - secondNum[0]);
            let res = [];
            let i = 0;

            while (i < intervals.length) {
                cur = intervals[i];//[start,end]
                let j = i + 1;

                while (j < intervals.length && intervals[j][0] <= cur[1]) {
                    cur[1] = Math.max(cur[1], intervals[j][1]);
                    j++;
                };

                res.push(cur);
                i = j;
            };

            return res;
        }

        //  merge([[1, 3], [2, 6], [8, 10], [15, 18]]);
        //  merge( [[1,4],[4,5]]);


        //57. Insert Interval
        //solution: find the index to insert the newInterval, then fall merge for the updated intervals.
        const insert = function (intervals, newInterval) {
            for (var i = 0; i < intervals.length; i++) { // var has function scope, can be acessed outside the block
                if (intervals[i][1] > newInterval[0]) {
                    break;
                }
            };
            console.log(i);
            intervals.splice(i + 1, 0, newInterval);
            return merge(intervals);

        };

        //insert( [[1,2],[3,5],[6,7],[8,10],[12,16]], [4,8])
        // insert([[1,5]], [0,3]);

        //575 Distribute Candies
        const distributeCandies = function (candyType) {
            let total = candyType.length / 2;
            let set = new Set();

            for (const candy of candyType) {
                set.add(candy);
            };

            return Math.min(set.size, total);
        };

        // distributeCandies([1,1,2,2,3,3])

        // 781 rabbits森林中的小兔子
        const numRabbits = function (answers) {
            let map = new Map();
            let res = 0;

            for (const type of answers) {
                if (map.has(type)) {
                    count = map.get(type);
                    count++;
                    map.set(type, count)
                } else (
                    map.set(type, 1)
                )
            };

            for (const [key, value] of map) {
                if (key === 0) {
                    res += value;
                } else {
                    if (value % (key + 1) === 0) {
                        res += value / (key + 1) * (key + 1);
                    } else {
                        res += Math.floor(value / (key + 1)) * (key + 1) + key + 1;
                    }
                }
            };

            return res;
        };
        // numRabbits([1,1,2]);
        //numRabbits([1, 0, 1, 0, 0]);

        //42 trapping-rain-water
        const trap = function (height) {
            let stack = [];
            let area = 0;
            let maxarea = 0;

            for (let i = 0; i < height.length; i++) {
                let count = 0;
                while (stack.length !== 0 && height[i] >= height[stack[stack.length - 1]]) { //新元素大于栈顶元素
                    var lastpop = stack.pop();
                    if (stack.length) { count += height[lastpop] };
                };

                if (lastpop) {
                    area = height[lastpop] * (i - lastpop - 1) - count;
                    maxarea += area;
                }


                stack.push(i);
            };



        }

        //trap([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1])

        // 11. Container With Most Water
        // 单调递减栈 放坐标 
        /* const maxArea1 = function(height) {
          let stack = [];
          let area = 0;
          let maxarea = 0;
  
          for(let i=0; i<height.length;i++) {
              while(stack.length!== 0 && height[i] > height[stack[stack.length -1]]){ //新元素大于栈顶元素
                  stack.pop();
              };
              stack.push(i);
              area = height[i] * (i- stack[0]); // 栈顶元素（新） *  宽度
              maxarea = Math.max(maxarea, area);
          };
  
          return maxarea;
  
         };
  
         //maxArea1([1,8,6,2,5,4,8,3,7]);
         maxArea1([1,2,1])  // not working , failed on this case
         */


        // 24 24. Swap Nodes in Pairs
        const swapPairs = function (head) {
            if (!head) return null;
            if (head.next === null) return head;

            let dumpH = new ListNode();
            dumpH.next = head;
            let pre = dumpH;

            while (head && head.next) {  // IMPORTANT head.next !== null  so that only swap when there are two nodes 
                let tmp = head.next;
                head.next = head.next.next;
                pre.next = tmp;
                tmp.next = head;

                pre = head;
                head = head.next;
            };

            return dumpH.next;

        };

        //54. Spiral Matrix
        const spiralOrder = function (matrix) {
            const m = matrix.length;
            const n = matrix[0].length;
            let res = [];
            let top = 0, bottom = m - 1;
            let left = 0, right = n - 1;

            while (top <= bottom && left <= right) {
                for (let i = left; i <= right; i++) {  // left -> right
                    res.push(matrix[top][i]);
                };
                top++;
                for (let j = top; j <= bottom; j++) { // top -> bottom
                    res.push(matrix[j][right]);
                };
                right--;
                if (res.length === m * n) break; // 这里需要加这句条件，否则就会重复遍历          
                for (let i = right; i >= left; i--) { // right -> left
                    res.push(matrix[bottom][i]);
                };
                bottom--;
                for (let j = bottom; j >= top; j--) { // bottom -> top
                    res.push(matrix[j][left]);
                };
                left++;
            };

            return res;
        };

        //spiralOrder([[1,2,3],[4,5,6],[7,8,9]]);
        //spiralOrder([[1,2,3,4],[5,6,7,8],[9,10,11,12]]);

        //61. Rotate List
        const mylist = {
            val: 1,
            next: {
                val: 2,
                next: {
                    val: 3,
                    next: {
                        val: 4,
                        next: {
                            val: 5,
                            next: null
                        }
                    }
                }
            }
        };
        // 快慢指针
        const rotateRight = function (head, k) {
            // special cases
            if (!head) return null;
            if (k === 0) return head;

            let fast = head;
            let slow = head;

            while (k > 0) {
                if (fast.next === null) {
                    fast = head;
                } else {
                    fast = fast.next;
                }
                k--;
            };

            while (fast.next) { // while fast 的话，当fast指向最后一个节点5时，判断条件为true，所以还会再往下走一个节点。
                slow = slow.next;
                fast = fast.next;
            };

            let dumh = head;
            head = (slow.next === null)? head: slow.next; // 如果slow指向最后一个节点的话，head就等于自身。
            fast.next = dumh;
            slow.next = null;  // 这句写在上一句后面，可以切断circle链表

            return head;
        };

        // solution 2: count the size, k%size 
        const rotateRight2 = function (head, k) {
            if(!head) return null;
            let size = 1; 
            let dumh = head;
            while(dumh.next){
                dumh= dumh.next;
                size++;
            };

            let move = (k%size===0)? 0 : size-k%size;
            dumh.next = head;
            while(move >0) {
                dumh= dumh.next;
                move--;
            };
            head = dumh.next;
            dumh.next = null;

            return head;
        }

       // rotateRight2(mylist, 2);
       // rotateRight2({val:1, next:null},1)

    </script>

</body>

</html>