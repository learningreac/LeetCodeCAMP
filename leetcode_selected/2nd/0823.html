<!<!DOCTYPE html>
	<html>

	<head>
		<meta charset="utf-8">
		<title></title>
	</head>

	<body>
		<script type="text/javascript">
			//704 binary search
			const search = function (nums, target) {
				let left = 0;
				let right = nums.length - 1;

				while (left <= right) {
					let middle = Math.floor((left + right) / 2);
					//console.log(middle);
					if (nums[middle] > target) right = middle - 1;
					else if (nums[middle] < target) left = middle + 1;
					else return middle;
				};

				return -1;

			};

			//278 first bad version
			const solution = function (isBadVersion) {
				/**
				 * @param {integer} n Total versions
				 * @return {integer} The first bad version
				 */
				return function (n) {
					let left = 0;
					let right = n;


					while (left <= right) {
						let mid = Math.floor((left + right) / 2)
						if (isBadVersion(mid))
							right = mid - 1
						else
							left = mid + 1
					}

					return left

				};
			};


			//35. Search Insert Position
			const searchInsert = function (nums, target) {
				let left = 0
				let right = nums.length - 1

				while (left <= right) {
					let mid = Math.floor((left + right) / 2)
					if (nums[mid] === target)
						return mid
					else if (nums[mid] < target)
						left = mid + 1
					else
						right = mid - 1
				}

				return left

			};

			//977.  Squares of a Sorted Array

			const sortedSquares1 = function (nums) {

				return nums
					.map(item => item * item)
					.sort((a, b) => a - b)
			};


			const sortedSquares = function (nums) {
				let res = [];
				let stack = []

				for (let i = 0; i < nums.length; i++) {
					let tmp = nums[i] * nums[i]

					nums[i] < 0
						?
						stack.unshift(tmp)
						:
						res.push(stack && tmp > stack[0]
							? (i--, stack.shift())    // i-- 因为当前这位没有被放入结果集，结果集放了栈里面的小元素，所以当前这位要重新比较一下，跟栈里面第二小再比较一轮 
							: tmp
						);
				}

				return res.concat(stack) // 避免了栈里只有一个元素的情况
			}


			//189. Rotate Array
			//Given an array, rotate the array to the right by k steps, where k is non-negative.

			const rotate1 = function (nums, k) {
				while (k > 0) {
					nums.unshift(nums.pop())
					k--
				}
			};// 超出时间限制

			// reverse方法

			const rotate = function (nums, k) {
				nums.reverse();

			}


			//283. Move Zeroes
			//Given an integer array nums, move all 0's to the end of it while maintaining the relative order of the non-zero elements.
			const moveZeroes = function (nums) {
				let slow = 0;
				let fast = slow + 1;

				while (fast < nums.length) {
					if (nums[slow] != 0) {
						slow++;
						fast++;
					} else {
						if (nums[fast] != 0) {
							[nums[slow], nums[fast]] = [nums[fast], nums[slow]];
							slow++;
							fast++
						}
						else {
							fast++
						}// fast also points to zero

					}

				}

			};


			const binarySearch2 = function (nums, t) {
				let left = 0;
				let right = nums.length - 1;

				while (left <= right) {
					let mid = Math.floor((left + right) / 2)
					if (nums[mid] < t) {
						left = mid + 1
					} else if (nums[mid] > t) {
						right = mid - 1
					} else if (nums[mid] === t) {
						return mid;
					}
				}
			}

			//167. Two Sum II - Input array is sorted
			const twoSum1 = function (numbers, target) {
				let index;
				let i = 0;

				for (i; i < numbers.length; i++) {

					let newTarget = target - numbers[i];
					index = binarySearch2(numbers.slice(i + 1), newTarget);
					if (index !== undefined) {
						return [i + 1, index + i + 2]
					}
				}
			}

			//twoSum([5,25,75],100)

			// case:[0,0,3,4]
			// case [5,25,75]

			//167. Two Sum II - Input array is sorted
			// array.indexOf
			const twoSum = function (numbers, target) {

				// two pointers
				// indexOf()

			}


			//344. Reverse String
			const reverseString = function (s) {
				let left = 0;
				let right = s.length - 1

				while (left <= right) {
					[s[left], s[right]] = [s[right], s[left]];
					left++;
					right--
				}

				return s // if or not retun matters // swap change the original array
			};

			//557. Reverse Words in a String III
			const reverseWords1 = function (s) {
				let splited = s.split('');
				let reveresed = [];

				let slow = 0; let fast = 0;
				while (splited.length > 0) {


					if (splited[fast] !== ' ' && fast <= splited.length) {
						fast++
					} else {
						let tempt = splited.splice(slow, fast);
						reverseString(tempt);
						reveresed = reveresed.concat(tempt);
						if (splited.length) {
							reveresed = reveresed.concat(splited.shift())
						};
						slow = 0;
						fast = 0;
					}
				}

				return reveresed.join('');

			};



			const reverseWords2 = function (s) {
				// js array.split(' ') seperate the words by white space
				let words = s.split(' ');
				let res = []
				words.forEach(word => {
					let reversed = reverseString(word.split(''));
					res.push(reversed.join(''))
				});

				return res.join(' ')

			}


			var reverseWords = function (s) {
				let arr = s.split("").reverse().join("")
				return arr.split(" ").reverse().join(" ")
			};
			//reverseWords("Let's take LeetCode contest")


			function ListNode(val, next) {
				this.val = (val === undefined ? 0 : val)
				this.next = (next === undefined ? null : next)
			}

			//19. Remove Nth Node From End of List
			const removeNthFromEnd = function (head, n) {
				let dumpy = new ListNode(null);  // for the case you need delete the first element of head
				dumpy.next = head;

				let fast = dumpy;
				let slow = dumpy;


				while (n > 0) {
					fast = fast.next;
					if (fast.next === null) {
						//fast.next = slow   ===> this will cause the list be endless
					}
					n--
				};

				while (fast.next) { // if fast.next === null, the Boolean value is false, won't go inside while
					fast = fast.next;
					slow = slow.next;
				};

				slow.next = slow.next.next;

				console.log(dumpy.next)
				return dumpy.next;

			};

			const mylist = {
				val: 4,
				next: {
					val: 5,
					next: {
						val: 1,
						next: {
							val: 9,
							next: null
						}
					}
				}
			}

			const tc2 = {
				val: 1,
				next: {
					val: 2,
					next: null
				}
			};

			const tc1 = {
				val: 1,
				next: null
			};

			//removeNthFromEnd(tc2, 2)
			//removeNthFromEnd(tc1, 1)


			// 滑动窗口
			//3. Longest Substring Without Repeating Characters
			const lengthOfLongestSubstring1 = function (s) {

				let maxLength = 0;

				if (s.length <= 1) return s.length;

				for (let slow = 0, fast = 1; fast < s.length;) {
					//between the slow and fast 在快慢指针之间，如果当前fast的指向的字母在这个区间出现过
					for (let i = slow; i < fast; i++) {
						if (s[i] === s[fast]) {
							slow = i + 1;  //slow 指向重复字母的下一个；
						};
					}

					//console.log(slow,fast);
					maxLength = Math.max(maxLength, fast - slow + 1);
					fast++; // move one to the right

				}

				return maxLength;

			};


			function lengthOfLongestSubstring(s) {
				let len = s.length;
				let result = 0;

				for (let i = 0; i < len; i++) {
					let set = new Set();
					let maxLen = 0;
					// 从i的位置遍历得到最长子串的长度
					let j = i;
					while (j < len && !set.has(s[j])) { //如果出现已出现的值，就不再进入while
						set.add(s[j]);
						maxLen++;
						j++;
					}
					// 取历史最大值 此时说明发现重复值了，计算当前的长度，然后更新i
					result = Math.max(result, maxLen);
				}
				return result;
			}

			//lengthOfLongestSubstring('abcafe')

			//567. Permutation in String
			const checkInclusion1 = function (s1, s2) {
				let s1Set = new Set();
				for (let i = 0; i < s1.length; i++) {
					s1Set.add(s1[i])
				};

				for (let i = 0; i < s2.length; i++) {
					let set2 = new Set(s1Set);
					for (let j = i; j < i + s1.length; j++) {
						if (!set2.has(s2[j])) break;
						if (set2.has(s2[j])) {
							set2.delete(s2[j])
						};
						if (set2.size === 0) return true
					}
				}

				return false

			};

			//checkInclusion( "ab", "eidbaooo")
			//checkInclusion("hello","ooolleoooleh")  // couln't pass this one, as A value in the Set may only occur once; 

			const checkInclusion = function (s1, s2) {
				let set1 = new Map();
				for (let i = 0; i < s1.length; i++) {
					if (set1.has(s1[i])) {
						let val = set1.get(s1[i]);
						set1.set(s1[i], ++val)
					} else {
						set1.set(s1[i], 1)
					}

				};

				for (let i = 0; i < s2.length; i++) {
					let set2 = new Map(set1);
					let resArr = [];
					for (let j = i; j < i + s1.length; j++) {
						if (!set2.has(s2[j])) break;
						if (set2.has(s2[j])) {
							let val = set2.get(s2[j]);
							set2.set(s2[j], --val)
						};
						//if(set2.size === 0 ) return true
						for (const value of set2.values()) {
							resArr.push(value);
						}
						if (resArr.every(value => value === 0)) {
							return true
						}
						resArr = [];
					}
				}

				return false

			};

			//checkInclusion("hello","ooolleoooleh")   /// 

			//733. Flood Fill DFS
			const floodFill = function (image, sr, sc, newColor) {
				if (image[sr][sc] === newColor) {
					return image;
				}

				const oldColor = image[sr][sc];

				const dfs = (sr, sc) => {
					if (
						sr < 0 ||
						sc < 0 ||
						sr >= image.length ||
						sc >= image[0].length ||
						image[sr][sc] !== oldColor
					) {
						return;
					}

					image[sr][sc] = newColor;

					dfs(sr - 1, sc);
					dfs(sr + 1, sc);
					dfs(sr, sc - 1);
					dfs(sr, sc + 1);
				}

				dfs(sr, sc);
				return image

			};


			//617. Merge Two Binary Trees
			const mergeTrees1 = function (root1, root2) {
				if (root1 == null && root2) {
					return root2
				}
				if ((root1 && root2 == null) || (root1 == null && root2 == null)) {
					return root1
				}

				root1.val += root2.val;


				root1.left = mergeTrees(root1.left, root2.left);
				root1.right = mergeTrees(root1.right, root2.right);

				return root1
			};

			const mergeTrees = function (root1, root2) {
				//递归出口
				if (!root1) return root2;
				if (!root2) return root1;

				root1.val += root2.val;

				//recursion
				root1.left = mergeTrees(root1.left, root2.left);
				root1.right = mergeTrees(root1.right, root2.right);

				return root1;
			}

			//116. Populating Next Right Pointers in Each Node
			/**
				* // Definition for a Node.
				* function Node(val, left, right, next) {
			*    this.val = val === undefined ? null : val;
				*    this.left = left === undefined ? null : left;
			*    this.right = right === undefined ? null : right;
				*    this.next = next === undefined ? null : next;
				* };
				*/

			/**
			 * @param {Node} root
			 * @return {Node}
			 */
			//BFS
			const connect1 = function (root) {
				let queue = [];

				if (root) queue.push(root);

				while (queue.length > 0) {
					let levelSize = queue.length;

					while (levelSize > 0) {
						let node = queue.shift();
						levelSize--;

						//左右节点入列
						if (node.left) queue.push(node.left);
						if (node.right) queue.push(node.right);

						//当前层最后一个节点指向next指向null
						if (levelSize === 0) node.next = null;

						if (levelSize > 0) node.next = queue[0]
					}
				};

				return root

			};


			//DFS
			const connect2 = function (root) {
				if (root == null || root.left == null) {
					return root;
				}
				root.left.next = root.right;//(修改当前的下一层)
				root.right.next = root.next === null ? null : root.next.left //(修改当前的下下层)
				root.left = connect(root.left);
				root.right = connect(root.right);

				return root;
			}

			//不需要修改每层最后一个节点的Next,因为它本来就定义为null
			const connect = function (root) {
				if (root === null) return root;

				const dfs = (node) => {
					if (node.left === null && node.right === null) return; // leaf node

					node.left.next = node.right;
					if (node.next) node.right.next = node.next.left; // node.next在上一层已经被修改

					dfs(node.left); // depth first 左枝一直前进到叶子节点
					dfs(node.right);

				}

				dfs(root);
				return root;

			}

			//542. 01 Matrix
			const updateMatrix = function (mat) {
				const m = mat.length;
				const n = mat[0].length;
				let dp = new Array(m).fill(0).map(i => new Array(n));  // empty two-D array

				for (let i = 0; i < m; i++) {
					for (let j = 0; j < n; j++) {
						dp[i][j] = mat[i][j] === 0 ? 0 : 10000
					}
				} // 如果matrix是零，那么该格子值就是0

				for (let i = 0; i < m; i++) {
					for (let j = 0; j < n; j++) {
						if (i >= 1) {
							dp[i][j] = Math.min(dp[i][j], dp[i - 1][j] + 1)
						}
						if (j >= 1) {
							dp[i][j] = Math.min(dp[i][j], dp[i][j - 1] + 1)
						}
					}
				}

				for (let i = m - 1; i >= 0; i--) {
					for (let j = n - 1; j >= 0; j--) {
						if (i + 1 < m) {
							dp[i][j] = Math.min(dp[i][j], dp[i + 1][j] + 1);
						}
						if (j + 1 < n) {
							dp[i][j] = Math.min(dp[i][j], dp[i][j + 1] + 1);
						}
					}
				}

				return dp

			}


			// 994. Rotting Oranges
			const orangesRotting = function (grid) {
				const m = grid.length;
				const n = grid[0].length;
				let queue = [];
				let sum = 0;
				let res = 0;

				for (let i = 0; i < m; i++) {
					for (let j = 0; j < n; j++) {
						if (grid[i][j] === 2) {
							queue.push([i, j])
						} else if (grid[i][j] === 1) {
							sum++
						}
					}
				}

				if (sum === 0) return res;

				while (sum > 0 && queue.length) {
					let levelSize = queue.length;
					res++;

					while (levelSize > 0) {
						let node = queue.shift();
						let row = node[0];
						let col = node[1];

						//left
						if (row - 1 >= 0 && grid[row - 1][col] === 1) {
							grid[row - 1][col] = 2;
							queue.push([row - 1, col]);
							sum--;
						};
						//right
						if (row + 1 < m && grid[row + 1][col] === 1) {
							grid[row + 1][col] = 2;
							queue.push([row + 1, col]);
							sum--;
						};
						//up
						if (col - 1 >= 0 && grid[row][col - 1] === 1) {
							grid[row][col - 1] = 2;
							queue.push([row, col - 1]);
							sum--
						};
						//bottom
						if (col + 1 < n && grid[row][col + 1] === 1) {
							grid[row][col + 1] = 2;
							queue.push([row, col + 1]);
							sum--
						}
						levelSize--;
					}
				};// end while

				/*	if (sum > 0) {
						return -1
					} else {
						return res
					}
				*/

				return sum > 0 ? -1 : res
			};

			//orangesRotting([[2, 1, 1], [1, 1, 0], [0, 1, 1]])
			//orangesRotting([[1,2]])

			//24. Swap Nodes in Pairs
			const swapPairs = function (head) {
				let dumpH = new ListNode(null);
				dumpH.next = head;

				while (head.next) {
					let tmp = head.next;


				}
			}


			//08.06 hanota
			const hanota = function (A, B, C) {
				let source;
				source = source === A ? B : A
				let tmp;
				tmp = tmp === B ? A : B

				let toBeMoved = source.splice(1);
				hanota(toBeMoved, tmp, C);
				C.push(source.pop())

				return C

			};

			//217
			const containsDuplicate1 = function (nums) {
				for (let i = 0; i < nums.length; i++) {
					for (let j = i + 1; j < nums.length; j++) {
						if (nums[i] === nums[j]) return true
					}
				}
				return false
			};

			const containsDuplicate = function (nums) {
				let numSet = new Set();
				for (let i = 0; i < nums.length; i++) {
					if (!numSet.has(nums[i])) {
						numSet.add(nums[i])
					} else {
						return true
					}
				};

				return false
			}

			// another solution : sort the array first

			//26. 删除有序数组中的重复项 26. Remove Duplicates from Sorted Array
			const removeDuplicates = function (nums) {
				for (var i = 0, j = i + 1; j < nums.length;) {
					if (nums[i] === nums[j]) {
						j++
					} else {
						[nums[i + 1], nums[j]] = [nums[j], nums[i + 1]]; //swap i+1 and j
						i++;
						j++;
						//console.log('i',i)
					}
				}

				return i + 1

			};

			//removeDuplicates([0, 0, 1, 1, 1, 2, 2, 3, 3, 4])

			//53. Maximum Subarray

			const maxSubArray = function (nums) {
				let dp = new Array(nums.length);
				dp[0] = nums[0];
				let max = nums[0]; // max should not be zero as the num might be negative

				if (nums.length === 1) return max; // special case

				for (let i = 1; i < dp.length; i++) {
					dp[i] = Math.max(dp[i - 1] + nums[i], nums[i]);
					max = Math.max(dp[i], max);
				}

				return max;
			};

			//88. Merge Sorted Array
			const merge1 = function (nums1, m, nums2, n) {
				let i = 0, j = 0;

				while (j < n && m <= nums1.length) {
					if (nums1[i] <= nums2[j]) {
						i++
					} else {    // nums1[i] > nums2[j]  insert nums2[j]
						// 先把需要插入的数 放入nums1中
						nums1[m] = nums2[j];

						// 把该数交换到 i 的位置 需要交换 m - i 次
						let cur = m;
						while (cur > i) {  // between i and current m
							if (nums1[cur] < nums1[cur - 1]) {
								[nums1[cur - 1], nums1[cur]] = [nums1[cur], nums1[cur - 1]];
								cur--

							}
						}
						m++; // m 指向下一个空 0
						i++;
						j++;
					}
				}
			};

			// use array.sort() directly
			const merge2 = function (nums1, m, nums2, n) {
				// put nums2 at the tail of nums1
				for (let i = 0; i < n; i++) {
					nums1[m + i] = nums2[i]
				}

				//  nums1.splice(m, nums1.length - m, ...nums2);

				nums1.sort((a, b) => a - b)
			}
			//merge([1,2,3,0,0,0],3,[2,5,6],3)

			// quick sort nums1 [1, 2, 3, 2, 5, 6], the pilot start from m-1
			const quickSort = function (nums, i, j) {
				quickSort(nums, 0, j - 1);
				quickSort(nums, j + 1, nums.length - 1)

			}

			const partition = function (nums, i, j) {
				let index = i;
				let pivot = nums[index];

				while (i <= j) {
					while (nums[i] <= pivot) {
						i++;
					};
					while (nums[j] > pivot) {
						j--;
					};

					[nums[i], nums[j]] = [nums[j], nums[i]];
					i++; j--;
				}
				[nums[index], nums[j]] = [nums[j], nums[index]]; // pivot 归位
			}
			//quickSort(nums, 0, nums.length-1)
			//quickSort([7, 5, 8, 1, 6, 3, 9], 0, 6)


			// 349  Intersection of Two Arrays (unique)
			// if two for loop, the time is O(m*n)
			// if use two set, the time is O(m+n)

			const intersection1 = function (nums1, nums2) {
				let set1 = new Set();
				let set2 = new Set();
				nums1.forEach(num => set1.add(num));
				nums2.forEach(num => set2.add(num));

				const getIntersection = function (set1, set2) { //set1 is shorter
					let res = [];
					for (const num of set1) {
						if (set2.has(num)) {
							res.push(num);
						}
					}
					return res;
				}

				return set1.size < set2.size       // size matters
					? getIntersection(set1, set2)
					: getIntersection(set2, set1)
			}

			// Sort array first -------  Intersection of Two Sorted Arrays
			const intersection = function (nums1, nums2) {
				nums1.sort((a, b) => a - b);
				nums2.sort((a, b) => a - b);
				let res = [];
				let i = 0, j = 0;

				while (i < nums1.length && j < nums2.length) {
					if (nums1[i] < nums2[j]) {
						i++;
						continue;
					};
					if (nums1[i] > nums2[j]) {
						j++;

						continue;
					};
					if (nums1[i] === nums2[j]) {
						if (res.indexOf(nums1[i]) === -1) {
							res.push(nums1[i]);
						};
						i++;
						j++;
					};
				}

				return res;

			}

			//intersection([4,9,5],[9,4,9,8,4]);
			//intersection([1, 2], [1, 1])

			//350. Intersection of Two Arrays II   the solution is not completely correct 09/12/2021

			const getIntersection = function (arr1, arr2) {   // arr1 is shorter
				let res = new Map();
				for (let i = 0; i < arr1.length; i++) {
					for (let j = 0; j < arr2.length; j++) {
						if (arr1[i] === arr2[j]) {
							res.set(i, arr1[i]);
						}
					}
				}
				console.log(res);
				return Array.from(res.values());
			}

			const intersect1 = function (nums1, nums2) {
				return nums1.length <= nums2.length
					? getIntersection(nums1, nums2)
					: getIntersection(nums2, nums1)
			};
			//---------------------------------------------------------------------
			const intersect = function (nums1, nums2) {
				nums1.sort((a, b) => a - b);
				nums2.sort((a, b) => a - b);
				let res = [];
				let i = 0, j = 0;

				while (i < nums1.length && j < nums2.length) {
					if (nums1[i] < nums2[j]) {
						i++;
						continue;
					};
					if (nums1[i] > nums2[j]) {
						j++;

						continue;
					};
					if (nums1[i] === nums2[j]) {
						res.push(nums1[i]);
						i++;
						j++;
					};
				}
				return res;
			}

			//intersect([4,9,5],[9,4,9,8,4])


			//121. Best Time to Buy and Sell Stock
			// run out of time 暴力解法
			const maxProfit1 = function (prices) {
				let profit = 0;
				for (let i = 0; i < prices.length;) {
					if (prices[i] > prices[i + 1]) {
						i++
					}
					for (let j = i + 1; j < prices.length; j++) {
						profit = Math.max(profit, prices[j] - prices[i])
					}
					i++
				}

				return profit
			};

			//单调栈   minstack
			const maxProfit2 = function (prices) {
				let minStack = [];
				let max = 0;
				prices.push(0);

				for (const price of prices) {

					while (minStack.length > 0 && price <= minStack[minStack.length - 1]) { // 弹出直到当前栈底为最小元素
						max = Math.max(max, minStack[minStack.length - 1] - minStack[0]);
						minStack.pop(); // 弹出栈顶元素 5;
					}

					minStack.push(price);
				}

				return max;
			};

			//Greedy  Time O(n)  Space O(1);
			const maxProfit3 = function (prices) {
				let low = prices[0]; // low need to have a value to make sure Math.min() works
				let res = 0;
				for (const price of prices) {
					low = Math.min(low, price);
					res = Math.max(res, price - low)
				}
				return res;
			}

			//DP
			const maxProfit = function (prices) {
				let pre = 0;
				let res = 0;

				for (let i = 1; i < prices.length; i++) {
					let diff = prices[i] - prices[i - 1];

					// maxProfit(i) = maxprofit(i-1) + diff
					pre = Math.max(pre + diff, 0);
					res = Math.max(res, pre)
				}

				return res

			}


			//maxProfit([7,1,5,3,6,4])
			//maxProfit([2,1,2,1,0,1,2]);
			//maxProfit([3, 3, 5, 0, 0, 3, 1, 4])

			//dp
			const maxProfitII2 = function (prices) {
				let len = prices.length;
				let dp = new Array(len).fill(0).map(item => new Array(len));
				//dp[0][0] = 0;

				for (let i = 0; i < len; i++) {
					for (let j = i + 1; j < len; j++) {
						dp[i][i] = 0;
						dp[i][j] = Math.max(dp[i][j - 1], prices[j] - prices[i])
					}
				};

				console.log(dp)

			};

			//greedy
			const maxProfitII = function (prices) {
				// 在所有上涨交易日都做买卖，在所有下跌交易日都不做买卖
				let temp;
				let profit = 0;
				for (let i = 1; i < prices.length; i++) {
					temp = prices[i] - prices[i - 1];
					if (temp > 0) {
						profit += temp;
					}
				};
				return profit;
			}

			//566. Reshape the Matrix
			const matrixReshape1 = function (mat, r, c) {
				let m = mat.length; //row 
				let n = mat[0].length; //column

				if (m * n !== r * c) return mat;
				let res = new Array(r).fill(0).map(item => new Array(c));
				let row = 0;

				for (let i = 0; i < r; i++) {
					for (let j = 0; j < c; j++) {
						if (mat[row].length > 0) {
							let tmp = mat[row].shift();
							res[i][j] = tmp
						} else {
							row++;
							j--;
						}
					}
				};

				return res;
			};

			const matrixReshape = function (mat, r, c) {
				let m = mat.length; //row 
				let n = mat[0].length; //column
				if (m * n !== r * c) return mat;

				for (let i = 0; i < r; i++) {
					if (c >= n) {
						if (mat[i + 1]) {
							mat[i] = mat[i].concat(mat[i + 1].splice(0, c - mat[i].length))
						}

					};

					if (c < n) {
						let tmp = mat[i].splice(c);
						mat[i + 1] = tmp.concat(mat[i + 1]);
					}
				}

				console.log('mat now', mat);
				return n >= 1 ? mat.splice(0, r) : mat

			}

			//matrixReshape([[1, 2], [3, 4]], 2, 2)
			//matrixReshape([[1, 2], [3, 4], [5, 6]], 2, 3)
			//matrixReshape([[1, 2,3], [4,5, 6]], 3, 2)
			//matrixReshape([1,2,3,4],1,4)
			// matrixReshape([[1],[2],[3],[4]],2,2)   this case cannot pass need to be fixed

			//118. Pascal's Triangle
			const generate = function (numRows) {
				let res = new Array(numRows)
					.fill(0)
					.map((item, i) => new Array(i + 1));

				for (let i = 0; i < numRows; i++) {
					for (let j = 0; j < i + 1; j++) {
						if (j === 0 || j === res[i].length - 1) {
							res[i][j] = 1;
						} else {
							res[i][j] = res[i - 1][j - 1] + res[i - 1][j]
						}
					}
				}
				//console.log(res)
				return res;
			};


			//73. Set Matrix Zeroes
			// onther solution : mark row and column index seperately as true, if matrix[i][j] meet one of them, then that grid should be zero.
			const setZeroes = function (matrix) {
				let queue = [];
				let m = matrix.length;
				let n = matrix[0].length;

				for (let i = 0; i < m; i++) {
					for (let j = 0; j < n; j++) {
						if (matrix[i][j] === 0) {
							queue.push([i, j]);
						};
					};
				}

				while (queue.length > 0) {
					let temp = queue.shift();
					let row = temp[0];
					let col = temp[1];
					matrix.map((item, i) => i === row ? item.fill(0) : item);

					for (let i = 0; i < m; i++) {
						matrix[i][col] = 0
					}
				}

				return matrix

			};


			//36. Valid Sudoku
			const isValidSudoku = function (board) {
				let len = board.length;

				// test row
				for (let i = 0; i < len; i++) {
					let rowSet = new Set()
					for (let j = 0; j < len; j++) {
						if (board[i][j] === '.') continue;
						if (rowSet.has(board[i][j])) {
							return false
						} else {
							rowSet.add(board[i][j])
						}
					};
					console.log(rowSet);
				}

				// test column 
				for (let j = 0; j < len; j++) {
					let colSet = new Set()
					for (let i = 0; i < len; i++) {
						if (board[i][j] === '.') continue;
						if (colSet.has(board[i][j])) {
							return false
						} else {
							colSet.add(board[i][j])
						}
					};
					console.log('--', colSet);
				};

				// test square
				for (let i = 0; i < len; i += 3) {
					let squareSet = new Set()
					for (let j = 0; j < len; j += 3) {


						if (board[i][j] === '.') continue;
						if (squareSet.has(board[i][j])) {
							return false
						} else {
							squareSet.add(board[i][j])
						}

					};
					console.log(squareSet);
				}

				return true
			};

			/*	isValidSudoku([["5", "3", ".", ".", "7", ".", ".", ".", "."]
					, ["6", ".", ".", "1", "9", "5", ".", ".", "."]
					, [".", "9", "8", ".", ".", ".", ".", "6", "."]
					, ["8", ".", ".", ".", "6", ".", ".", ".", "3"]
					, ["4", ".", ".", "8", ".", "3", ".", ".", "1"]
					, ["7", ".", ".", ".", "2", ".", ".", ".", "6"]
					, [".", "6", ".", ".", ".", ".", "2", "8", "."]
					, [".", ".", ".", "4", "1", "9", ".", ".", "5"]
					, [".", ".", ".", ".", "8", ".", ".", "7", "9"]])

			*/


			//387. First Unique Character in a String
			// map: record all char and their index
			// set: record the char apprears once more

			// delete the items in map that set has
			//
			const firstUniqChar = function (s) {
				let charMap = new Map();
				let repeteSet = new Set();

				for (let i = 0; i < s.length; i++) {
					if (!charMap.has(s[i])) {
						charMap.set(s[i], i);
					} else {
						repeteSet.add(s[i]);
					}
				};

				repeteSet.forEach(item => charMap.delete(item));

				return charMap.size > 0 ? charMap.values().next().value : -1
			};

			//firstUniqChar("leetcode")
			//firstUniqChar("loveleetcode")


			//383. Ransom Note
			const canConstruct = function (ransomNote, magazine) {

				// harshmap for magazine record char and show times
				let magMap = new Map();
				for (let i = 0; i < magazine.length; i++) {
					if (!magMap.has(magazine[i])) {
						magMap.set(magazine[i], 1);
					} else {
						let key = magMap.get(magazine[i]);
						magMap.set(magazine[i], ++key);
					}
				};
				console.log(magMap)

				for (let j = 0; j < ransomNote.length; j++) {
					if (magMap.has(ransomNote[j])) {
						let key = magMap.get(ransomNote[j]);
						magMap.set(ransomNote[j], --key);
						if (key < 0) return false
					} else {
						return false
					}
				}

				return true;

			};

			//canConstruct('aa', 'aab');


			const scanToMap = function (string) {
				let temMap = new Map();
				for (let i = 0; i < string.length; i++) {
					if (!temMap.has(string[i])) {
						temMap.set(string[i], 1)
					} else {
						let value = temMap.get(string[i]);
						temMap.set(string[i], ++value)
					}
				}
				return temMap
			}

			//242. Valid Anagram

			// sort first then join,then compare 
			const isAnagram = function (s, t) {
				let sMap = scanToMap(s);
				let tMap = scanToMap(t);

				/*sMap.forEach((value, key) => {      // ***arguments order matters here
					if (!tMap.has(key)) {               // forEach accept a callback function, the return inside is not for the whole function,
						return false                    // but only for the inner function
					} else if (value !== tMap.get(key)) {
						return false
					} else 
				})
				*/

				for (const [key, value] of sMap.entries()) {
					if (!tMap.has(key) || value !== tMap.get(key)) {
						return false
					} else {
						tMap.delete(key);
						sMap.delete(key);
					}

				}

				return tMap.size === 0 && sMap.size === 0 ? true : false
			};

			// another solution:
			//harshmap S, then irrelate T,
			// if Smap.has(t[i]) --value  return false when key is negative or delete that key when value is zero
			// if !Smap.has(t[i])  return false
			// after irrelation for t, return false is Smap.size >0

			//isAnagram("rat", "car")
			//isAnagram('a', 'ab')


			//203. Remove Linked List Elements

			const mylist2 = {
				val: 1,
				next: {
					val: 2,
					next: {
						val: 6,
						next: {
							val: 3,
							next: null
						}
					}
				}
			};

			function ListNode(val, next) {
				this.val = (val === undefined ? 0 : val)
				this.next = (next === undefined ? null : next)
			};

			const removeElements1 = function (head, val) {
				let dumpH = new ListNode();
				dumpH.next = head;
				let pre = dumpH;

				while (dumpH.next) {
					if (dumpH.next.val === val) {
						dumpH.next = dumpH.next.next
					} else {
						dumpH = dumpH.next;
					}
				}
				return pre.next

			};

			// recursion
			const removeElements = function (head, val) {
				if (head === null) return null;
				head.next = removeElements(head.next, val);

				return head.val === val ? head.next : head

			}

			//removeElements(mylist2, 6)

			//695. Max Area of Island
			const maxAreaOfIsland = function (grid) {
				//let max = 0;  
				let res = 0;
				let queue = [];

				const dfs = function (r, c) {
					if (r < 0 || r >= grid.length || c < 0 || c >= grid[0].length || grid[r][c] !== 1) return 0;
					grid[r][c] = 0; // mark as read 
					let area = 1;

					area += dfs(r - 1, c) + dfs(r + 1, c) + dfs(r, c - 1) + dfs(r, c + 1);
					console.log(area);
					return area;
				};

				for (let i = 0; i < grid.length; i++) {
					for (let j = 0; j < grid[0].length; j++) {
						if (grid[i][j] === 1) {
							queue.push([i, j])
						}
					};
				};

				while (queue.length > 0) {
					let tmp = queue.shift();
					res = Math.max(res, dfs(tmp[0], tmp[1]))
				}

				return res;
			};
			//
			var maxAreaOfIsland2 = function (grid) {
				let ans = 0;
				let m = grid.length;
				let n = grid[0].length;
				let count = 0;
				const dfs = function (i, j) {
					if (i < 0 || j < 0 || i >= m || j >= n || grid[i][j] == '0') {
						//终止条件
						return;
					}
					//把陆地改为海洋，防止多次记录
					grid[i][j] = "0";
					//记录陆地
					count++;
					dfs(i - 1, j);
					dfs(i + 1, j);
					dfs(i, j - 1);
					dfs(i, j + 1);
				}

				for (let i = 0; i < m; i++) {
					for (let j = 0; j < n; j++) {
						if (grid[i][j] == '1') {
							dfs(i, j);
							//判断最大值
							ans = ans > count ? ans : count;
							//重置计数
							count = 0;
						}
					}
				}
				return ans;
			};
			//maxAreaOfIsland([[0, 0, 1], [0, 0, 0], [0, 1, 1], [0, 1, 0]])

			//83. Remove Duplicates from Sorted List
			const deleteDuplicates = function (head) {
				let slow = head;
				let fast = head;

				while (fast) {
					while (slow.val === fast.val) {
						fast = fast.next;
						if (fast === null) break;
					};
					// fast now is diff from slow;
					slow.next = fast;
					slow = slow.next;
					if (fast) { fast = fast.next; }
				}

				return head;
			};

			const mylist3 = {
				val: 1,
				next: {
					val: 1,
					next: {
						val: 2,
						next: {
							val: 2,
							next: null
						}
					}
				}
			};

			//deleteDuplicates(mylist3);

			//206. Reverse Linked List
			const reverseList = function (head) {
				let pre = null;

				while (head) {
					let cur = head;
					let tmp = head.next;
					head.next = pre;
					pre = cur;
					head = tmp;	// 最后一步操作时，tmp为null，所以head 就被擦除为null 了，所以下面返回时，返回pre
				};
				return pre;
			};

			//reverseList(mylist2);

			//77. Combination
			// [[1,2],[1,3],[1,4],[2,1],[2,3],[2,4],[3,1],[3,2],[3,4],[4,1],[4,2],[4,3]] 
			// 这种写法 是全排列！ 不是组合，[1,2] [2,1] 对于组合来说是一样的
			//预期结果[[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]
			const combine = function (n, k) {
				const res = [];
				//setup queue
				let queue = [];
				for (let i = 1; i <= n; i++) { queue.push(i) };
				if (k === 1) {
					for (const item of queue) {
						res.push([item])
					}
					return res;
				};
				let path = [];

				while (queue.length >= k) {
					for (let i = 0; i < queue.length; i++) {
						path.push(queue[i]);
						if (path.length === k) {
							res.push(path.slice());
							path.pop();
						}
					}
					path = [];
					queue.shift(); // 

				};
				return res;
			};

			//	combine(1, 1)

			//46. Permutations
			const permute = (nums) => {
				const res = [];
				const used = {};// HashMap

				function dfs(path) {
					if (path.length == nums.length) { // 个数选够了
						res.push(path.slice()); // 拷贝一份path，加入解集res
						return;                 // 结束当前递归分支
					}
					for (const num of nums) { // for枚举出每个可选的选项
						// if (path.includes(num)) continue; // 别这么写！查找的时间是O(n)，增加时间复杂度
						if (used[num]) continue; // 使用过的，跳过
						path.push(num);         // 选择当前的数，加入path
						used[num] = true;       // 记录一下 使用了  {num: true} 变成这样了
						dfs(path);              // 基于选了当前的数，递归
						path.pop();             // 上一句的递归结束，回溯，将最后选的数pop出来
						used[num] = false;      // 撤销这个记录
					}
				}

				dfs([]); // 递归的入口，空path传进去
				return res;
			};

			//20. Valid Parentheses
			const isValid = function (s) {
				if (s.length % 2) return false;  // length is odd 
				let dic = new Map([[')', '('], [']', '['], ['}', '{']]);
				let stack = [];

				for (const item of s) {
					// 遇到右括号，看下跟它相邻的是不是左括号，是的话，两者都抛出；
				}


			};

			function TreeNode(val, left, right) {
				this.val = (val === undefined ? 0 : val)
				this.left = (left === undefined ? null : left)
				this.right = (right === undefined ? null : right)
			}

			const mytree = new TreeNode(1, 2, 3);
			//101. 对称二叉树
			const isSymmetric = function (root) {
				if (!root) return true;

				const isMirror = function (left, right) {
					if (left === null && right === null) { return true }
					if (left && right) {
						return left.value === right.value && isMirror(left.left, right.right) && isMirror(left.right, right.left)
					}  // should be left.val   not value

					return false
				}
				return isMirror(root.left, root.right)
			};



			const isSymmetric2 = (root) => {

				const check = (left, right) => {
					if (left == null && right == null) { // 两个子树都为null，是对称的
						return true;
					}
					if (left && right) { // 两个子树都存在，则需要：root值相同，且他们的子树也满足镜像
						return left.val == right.val && check(left.left, right.right) && check(left.right, right.left);
					}
					return false;        // 一个子树存在一个不存在，肯定不对称
				};

				if (root == null) {     // 如果传入的root就是null，对称
					return true;
				}
				return check(root.left, root.right); // 否则，判断它的左右子树是否满足对称
			};

			//	isSymmetric2(mytree);

			//700. Search in a Binary Search Tree
			const searchBST = function (root, val) {
				if (!root || root.val === val) return root;

				return root.val > val ? searchBST(root.left, val) : searchBST(root.right, val)
			}

			// 226  Invert Binary Tree
			const invertTree = function (root) {
				if (!root) return null;
				let tmp = root.left;
				root.left = root.right;
				root.right = tmp;

				invertTree(root.left);
				invertTree(root.right);

				return root

			};
			//112. Path Sum
			/*	const hasPathSum = function (root, targetSum) {
					let sum = 0;
	
					const dfs = function (node) {
						if (!node) return;
						sum += node.val;
						if (sum === targetSum) {
							return true;
						} else if (sum < targetSum) {
							dfs(node.left)
						} else {
							sum -= node.val;
							dfs(node.right)
						};
					}
	
					dfs(root);
					return false;
				};
				*/


			const hasPathSum1 = function (root, sum) {
				// 遍历到叶子节点下一个节点-终止递归
				if (root === null) return false

				// 遍历到叶子节点 判断剩余节点是否与和差值未0
				if (root.left === null && root.right === null) {
					return (sum - root.val) === 0;
				}

				// sum一次减去该节点左节点、右节点 是否等于最后叶子节点
				let left = hasPathSum(root.left, sum - root.val),
					right = hasPathSum(root.right, sum - root.val);

				// 存在一侧满足就满足
				return left || right
			};

			// 回溯 Backtrack
			const hasPathSum2 = function (root, targetSum) {

				const traversal = function (node, sum) {
					if (!node.left && !node.right && sum === 0) return true; // leaf node && count is 0
					if (!node.left && !node.right) return false; // leaf node

					if (node.left) {
						sum -= node.left.val;
						if (traversal(node.left, sum)) return true;
						sum += node.left.val;
					}

					if (node.right) {
						sum -= node.right.val;
						if (traversal(node.right, sum)) return true;
						sum += node.right.val;
					}

					return false;
				}

				if (!root) return false;
				return traversal(root, targetSum - root.val)
			}

			//bfs
			const hasPathSum = function (root, targetSum) {
				if(!root) return false;
				let queue = [];
				queue.push([root, root.val]); // push to the end of the queue

				while(queue.length) {
					[node, sum] = queue.shift(); // get the first element from the queue

					if(!node.left && !node.right && sum === targetSum) return true;
					if(node.left) {
						queue.push([node.left, sum + node.left.val])
					};
					if(node.right) {
						queue.push([node.right, sum + node.right.val])
					};
				}
				return false;
			}

		</script>

	</body>

	</html>