<!<!DOCTYPE html>
	<html>

	<head>
		<meta charset="utf-8">
		<title></title>
	</head>

	<body>
		<script type="text/javascript">
			//704 binary search
			const search = function (nums, target) {
				let left = 0;
				let right = nums.length - 1;

				while (left <= right) {
					let middle = Math.floor((left + right) / 2);
					//console.log(middle);
					if (nums[middle] > target) right = middle - 1;
					else if (nums[middle] < target) left = middle + 1;
					else return middle;
				};

				return -1;

			};

			//278 first bad version
			const solution = function (isBadVersion) {
				/**
				 * @param {integer} n Total versions
				 * @return {integer} The first bad version
				 */
				return function (n) {
					let left = 0;
					let right = n;


					while (left <= right) {
						let mid = Math.floor((left + right) / 2)
						if (isBadVersion(mid))
							right = mid - 1
						else
							left = mid + 1
					}

					return left

				};
			};


			//35. Search Insert Position
			const searchInsert = function (nums, target) {
				let left = 0
				let right = nums.length - 1

				while (left <= right) {
					let mid = Math.floor((left + right) / 2)
					if (nums[mid] === target)
						return mid
					else if (nums[mid] < target)
						left = mid + 1
					else
						right = mid - 1
				}

				return left

			};

			//977.  Squares of a Sorted Array

			const sortedSquares1 = function (nums) {

				return nums
					.map(item => item * item)
					.sort((a, b) => a - b)
			};


			const sortedSquares = function (nums) {
				let res = [];
				let stack = []

				for (let i = 0; i < nums.length; i++) {
					let tmp = nums[i] * nums[i]

					nums[i] < 0
						?
						stack.unshift(tmp)
						:
						res.push(stack && tmp > stack[0]
							? (i--, stack.shift())    // i-- 因为当前这位没有被放入结果集，结果集放了栈里面的小元素，所以当前这位要重新比较一下，跟栈里面第二小再比较一轮 
							: tmp
						);
				}

				return res.concat(stack) // 避免了栈里只有一个元素的情况
			}


			//189. Rotate Array
			//Given an array, rotate the array to the right by k steps, where k is non-negative.

			const rotate1 = function (nums, k) {
				while (k > 0) {
					nums.unshift(nums.pop())
					k--
				}
			};// 超出时间限制

			// reverse方法

			const rotate = function (nums, k) {
				nums.reverse();

			}


			//283. Move Zeroes
			//Given an integer array nums, move all 0's to the end of it while maintaining the relative order of the non-zero elements.
			const moveZeroes = function (nums) {
				let slow = 0;
				let fast = slow + 1;

				while (fast < nums.length) {
					if (nums[slow] != 0) {
						slow++;
						fast++;
					} else {
						if (nums[fast] != 0) {
							[nums[slow], nums[fast]] = [nums[fast], nums[slow]];
							slow++;
							fast++
						}
						else {
							fast++
						}// fast also points to zero

					}

				}

			};


			const binarySearch2 = function (nums, t) {
				let left = 0;
				let right = nums.length - 1;

				while (left <= right) {
					let mid = Math.floor((left + right) / 2)
					if (nums[mid] < t) {
						left = mid + 1
					} else if (nums[mid] > t) {
						right = mid - 1
					} else if (nums[mid] === t) {
						return mid;
					}
				}
			}

			//167. Two Sum II - Input array is sorted
			const twoSum1 = function (numbers, target) {
				let index;
				let i = 0;

				for (i; i < numbers.length; i++) {

					let newTarget = target - numbers[i];
					index = binarySearch2(numbers.slice(i + 1), newTarget);
					if (index !== undefined) {
						return [i + 1, index + i + 2]
					}
				}
			}

			//twoSum([5,25,75],100)

			// case:[0,0,3,4]
			// case [5,25,75]

			//167. Two Sum II - Input array is sorted
			// array.indexOf
			const twoSum = function (numbers, target) {

				// two pointers
				// indexOf()

			}


			//344. Reverse String
			const reverseString = function (s) {
				let left = 0;
				let right = s.length - 1

				while (left <= right) {
					[s[left], s[right]] = [s[right], s[left]];
					left++;
					right--
				}

				return s // if or not retun matters // swap change the original array
			};

			//557. Reverse Words in a String III
			const reverseWords1 = function (s) {
				let splited = s.split('');
				let reveresed = [];

				let slow = 0; let fast = 0;
				while (splited.length > 0) {


					if (splited[fast] !== ' ' && fast <= splited.length) {
						fast++
					} else {
						let tempt = splited.splice(slow, fast);
						reverseString(tempt);
						reveresed = reveresed.concat(tempt);
						if (splited.length) {
							reveresed = reveresed.concat(splited.shift())
						};
						slow = 0;
						fast = 0;
					}
				}

				return reveresed.join('');

			};



			const reverseWords2 = function (s) {
				// js array.split(' ') seperate the words by white space
				let words = s.split(' ');
				let res = []
				words.forEach(word => {
					let reversed = reverseString(word.split(''));
					res.push(reversed.join(''))
				});

				return res.join(' ')

			}


			var reverseWords = function (s) {
				let arr = s.split("").reverse().join("")
				return arr.split(" ").reverse().join(" ")
			};
			//reverseWords("Let's take LeetCode contest")


			function ListNode(val, next) {
				this.val = (val === undefined ? 0 : val)
				this.next = (next === undefined ? null : next)
			}

			//19. Remove Nth Node From End of List
			const removeNthFromEnd = function (head, n) {
				let dumpy = new ListNode(null);  // for the case you need delete the first element of head
				dumpy.next = head;

				let fast = dumpy;
				let slow = dumpy;


				while (n > 0) {
					fast = fast.next;
					if (fast.next === null) {
						//fast.next = slow   ===> this will cause the list be endless
					}
					n--
				};

				while (fast.next) { // if fast.next === null, the Boolean value is false, won't go inside while
					fast = fast.next;
					slow = slow.next;
				};

				slow.next = slow.next.next;

				console.log(dumpy.next)
				return dumpy.next;

			};

			const mylist = {
				val: 4,
				next: {
					val: 5,
					next: {
						val: 1,
						next: {
							val: 9,
							next: null
						}
					}
				}
			}

			const tc2 = {
				val: 1,
				next: {
					val: 2,
					next: null
				}
			};

			const tc1 = {
				val: 1,
				next: null
			};

			//removeNthFromEnd(tc2, 2)
			//removeNthFromEnd(tc1, 1)


			// 滑动窗口
			//3. Longest Substring Without Repeating Characters
			const lengthOfLongestSubstring1 = function (s) {

				let maxLength = 0;

				if (s.length <= 1) return s.length;

				for (let slow = 0, fast = 1; fast < s.length;) {
					//between the slow and fast 在快慢指针之间，如果当前fast的指向的字母在这个区间出现过
					for (let i = slow; i < fast; i++) {
						if (s[i] === s[fast]) {
							slow = i + 1;  //slow 指向重复字母的下一个；
						};
					}

					//console.log(slow,fast);
					maxLength = Math.max(maxLength, fast - slow + 1);
					fast++; // move one to the right

				}

				return maxLength;

			};


			function lengthOfLongestSubstring(s) {
				let len = s.length;
				let result = 0;

				for (let i = 0; i < len; i++) {
					let set = new Set();
					let maxLen = 0;
					// 从i的位置遍历得到最长子串的长度
					let j = i;
					while (j < len && !set.has(s[j])) { //如果出现已出现的值，就不再进入while
						set.add(s[j]);
						maxLen++;
						j++;
					}
					// 取历史最大值 此时说明发现重复值了，计算当前的长度，然后更新i
					result = Math.max(result, maxLen);
				}
				return result;
			}

			//lengthOfLongestSubstring('abcafe')

			//567. Permutation in String
			const checkInclusion1 = function (s1, s2) {
				let s1Set = new Set();
				for (let i = 0; i < s1.length; i++) {
					s1Set.add(s1[i])
				};

				for (let i = 0; i < s2.length; i++) {
					let set2 = new Set(s1Set);
					for (let j = i; j < i + s1.length; j++) {
						if (!set2.has(s2[j])) break;
						if (set2.has(s2[j])) {
							set2.delete(s2[j])
						};
						if (set2.size === 0) return true
					}
				}

				return false

			};

			//checkInclusion( "ab", "eidbaooo")
			//checkInclusion("hello","ooolleoooleh")  // couln't pass this one, as A value in the Set may only occur once; 

			const checkInclusion = function (s1, s2) {
				let set1 = new Map();
				for (let i = 0; i < s1.length; i++) {
					if (set1.has(s1[i])) {
						let val = set1.get(s1[i]);
						set1.set(s1[i], ++val)
					} else {
						set1.set(s1[i], 1)
					}

				};

				for (let i = 0; i < s2.length; i++) {
					let set2 = new Map(set1);
					let resArr = [];
					for (let j = i; j < i + s1.length; j++) {
						if (!set2.has(s2[j])) break;
						if (set2.has(s2[j])) {
							let val = set2.get(s2[j]);
							set2.set(s2[j], --val)
						};
						//if(set2.size === 0 ) return true
						for (const value of set2.values()) {
							resArr.push(value);
						}
						if (resArr.every(value => value === 0)) {
							return true
						}
						resArr = [];
					}
				}

				return false

			};

			//checkInclusion("hello","ooolleoooleh")   /// 

			//733. Flood Fill DFS
			const floodFill = function (image, sr, sc, newColor) {
				if (image[sr][sc] === newColor) {
					return image;
				}

				const oldColor = image[sr][sc];

				const dfs = (sr, sc) => {
					if (
						sr < 0 ||
						sc < 0 ||
						sr >= image.length ||
						sc >= image[0].length ||
						image[sr][sc] !== oldColor
					) {
						return;
					}

					image[sr][sc] = newColor;

					dfs(sr - 1, sc);
					dfs(sr + 1, sc);
					dfs(sr, sc - 1);
					dfs(sr, sc + 1);
				}

				dfs(sr, sc);
				return image

			};


			//617. Merge Two Binary Trees
			const mergeTrees1 = function (root1, root2) {
				if (root1 == null && root2) {
					return root2
				}
				if ((root1 && root2 == null) || (root1 == null && root2 == null)) {
					return root1
				}

				root1.val += root2.val;


				root1.left = mergeTrees(root1.left, root2.left);
				root1.right = mergeTrees(root1.right, root2.right);

				return root1
			};

			const mergeTrees = function (root1, root2) {
				//递归出口
				if (!root1) return root2;
				if (!root2) return root1;

				root1.val += root2.val;

				//recursion
				root1.left = mergeTrees(root1.left, root2.left);
				root1.right = mergeTrees(root1.right, root2.right);

				return root1;
			}

			//116. Populating Next Right Pointers in Each Node
			/**
				* // Definition for a Node.
				* function Node(val, left, right, next) {
			*    this.val = val === undefined ? null : val;
				*    this.left = left === undefined ? null : left;
			*    this.right = right === undefined ? null : right;
				*    this.next = next === undefined ? null : next;
				* };
				*/

			/**
			 * @param {Node} root
			 * @return {Node}
			 */
			//BFS
			const connect1 = function (root) {
				let queue = [];

				if (root) queue.push(root);

				while (queue.length > 0) {
					let levelSize = queue.length;

					while (levelSize > 0) {
						let node = queue.shift();
						levelSize--;

						//左右节点入列
						if (node.left) queue.push(node.left);
						if (node.right) queue.push(node.right);

						//当前层最后一个节点指向next指向null
						if (levelSize === 0) node.next = null;

						if (levelSize > 0) node.next = queue[0]
					}
				};

				return root

			};


			//DFS
			const connect2 = function (root) {
				if (root == null || root.left == null) {
					return root;
				}
				root.left.next = root.right;//(修改当前的下一层)
				root.right.next = root.next === null ? null : root.next.left //(修改当前的下下层)
				root.left = connect(root.left);
				root.right = connect(root.right);

				return root;
			}

			//不需要修改每层最后一个节点的Next,因为它本来就定义为null
			const connect = function (root) {
				if (root === null) return root;

				const dfs = (node) => {
					if (node.left === null && node.right === null) return; // leaf node

					node.left.next = node.right;
					if (node.next) node.right.next = node.next.left; // node.next在上一层已经被修改

					dfs(node.left); // depth first 左枝一直前进到叶子节点
					dfs(node.right);

				}

				dfs(root);
				return root;

			}

			//542. 01 Matrix
			const updateMatrix = function (mat) {
				const m = mat.length;
				const n = mat[0].length;
				let dp = new Array(m).fill(0).map(i => new Array(n));  // empty two-D array

				for (let i = 0; i < m; i++) {
					for (let j = 0; j < n; j++) {
						dp[i][j] = mat[i][j] === 0 ? 0 : 10000
					}
				} // 如果matrix是零，那么该格子值就是0

				for (let i = 0; i < m; i++) {
					for (let j = 0; j < n; j++) {
						if (i >= 1) {
							dp[i][j] = Math.min(dp[i][j], dp[i - 1][j] + 1)
						}
						if (j >= 1) {
							dp[i][j] = Math.min(dp[i][j], dp[i][j - 1] + 1)
						}
					}
				}

				for (let i = m - 1; i >= 0; i--) {
					for (let j = n - 1; j >= 0; j--) {
						if (i + 1 < m) {
							dp[i][j] = Math.min(dp[i][j], dp[i + 1][j] + 1);
						}
						if (j + 1 < n) {
							dp[i][j] = Math.min(dp[i][j], dp[i][j + 1] + 1);
						}
					}
				}

				return dp

			}


			// 994. Rotting Oranges
			const orangesRotting = function (grid) {
				const m = grid.length;
				const n = grid[0].length;
				let queue = [];
				let sum = 0;
				let res = 0;

				for (let i = 0; i < m; i++) {
					for (let j = 0; j < n; j++) {
						if (grid[i][j] === 2) {
							queue.push([i, j])
						} else if (grid[i][j] === 1) {
							sum++
						}
					}
				}

				if (sum === 0) return res;

				while (sum > 0 && queue.length) {
					let levelSize = queue.length;
					res++;

					while (levelSize > 0) {
						let node = queue.shift();
						let row = node[0];
						let col = node[1];

						//left
						if (row - 1 >= 0 && grid[row - 1][col] === 1) {
							grid[row - 1][col] = 2;
							queue.push([row - 1, col]);
							sum--;
						};
						//right
						if (row + 1 < m && grid[row + 1][col] === 1) {
							grid[row + 1][col] = 2;
							queue.push([row + 1, col]);
							sum--;
						};
						//up
						if (col - 1 >= 0 && grid[row][col - 1] === 1) {
							grid[row][col - 1] = 2;
							queue.push([row, col - 1]);
							sum--
						};
						//bottom
						if (col + 1 < n && grid[row][col + 1] === 1) {
							grid[row][col + 1] = 2;
							queue.push([row, col + 1]);
							sum--
						}
						levelSize--;
					}
				};// end while

				if (sum > 0) {
					return -1
				} else {
					return res
				}
			};

			//orangesRotting([[2, 1, 1], [1, 1, 0], [0, 1, 1]])
			orangesRotting([[1,2]])
		</script>

	</body>

	</html>