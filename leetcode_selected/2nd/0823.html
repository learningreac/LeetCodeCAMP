<!<!DOCTYPE html>
	<html>

	<head>
		<meta charset="utf-8">
		<title></title>
	</head>

	<body>
		<script type="text/javascript">
			//704 binary search
			const search = function (nums, target) {
				let left = 0;
				let right = nums.length - 1;

				while (left <= right) {
					let middle = Math.floor((left + right) / 2);
					//console.log(middle);
					if (nums[middle] > target) right = middle - 1;
					else if (nums[middle] < target) left = middle + 1;
					else return middle;
				};

				return -1;

			};

			//278 first bad version
			const solution = function (isBadVersion) {
				/**
				 * @param {integer} n Total versions
				 * @return {integer} The first bad version
				 */
				return function (n) {
					let left = 0;
					let right = n;


					while (left <= right) {
						let mid = Math.floor((left + right) / 2)
						if (isBadVersion(mid))
							right = mid - 1
						else
							left = mid + 1
					}

					return left

				};
			};


			//35. Search Insert Position
			const searchInsert = function (nums, target) {
				let left = 0
				let right = nums.length - 1

				while (left <= right) {
					let mid = Math.floor((left + right) / 2)
					if (nums[mid] === target)
						return mid
					else if (nums[mid] < target)
						left = mid + 1
					else
						right = mid - 1
				}

				return left

			};

			//977.  Squares of a Sorted Array

			const sortedSquares1 = function (nums) {

				return nums
					.map(item => item * item)
					.sort((a, b) => a - b)
			};


			const sortedSquares = function (nums) {
				let res = [];
				let stack = []

				for (let i = 0; i < nums.length; i++) {
					let tmp = nums[i] * nums[i]

					nums[i] < 0
						?
						stack.unshift(tmp)
						:
						res.push(stack && tmp > stack[0]
							? (i--, stack.shift())    // i-- 因为当前这位没有被放入结果集，结果集放了栈里面的小元素，所以当前这位要重新比较一下，跟栈里面第二小再比较一轮 
							: tmp
						);
				}

				return res.concat(stack) // 避免了栈里只有一个元素的情况
			}


			//189. Rotate Array
			//Given an array, rotate the array to the right by k steps, where k is non-negative.

			const rotate1 = function (nums, k) {
				while (k > 0) {
					nums.unshift(nums.pop())
					k--
				}
			};// 超出时间限制

			// reverse方法

			const rotate = function (nums, k) {
				nums.reverse();

			}


			//283. Move Zeroes
			//Given an integer array nums, move all 0's to the end of it while maintaining the relative order of the non-zero elements.
			const moveZeroes = function (nums) {
				let slow = 0;
				let fast = slow + 1;

				while (fast < nums.length) {
					if (nums[slow] != 0) {
						slow++;
						fast++;
					} else {
						if (nums[fast] != 0) {
							[nums[slow], nums[fast]] = [nums[fast], nums[slow]];
							slow++;
							fast++
						}
						else {
							fast++
						}// fast also points to zero

					}

				}

			};


			const binarySearch2 = function (nums, t) {
				let left = 0;
				let right = nums.length - 1;

				while (left <= right) {
					let mid = Math.floor((left + right) / 2)
					if (nums[mid] < t) {
						left = mid + 1
					} else if (nums[mid] > t) {
						right = mid - 1
					} else if (nums[mid] === t) {
						return mid;
					}
				}
			}

			//167. Two Sum II - Input array is sorted
			const twoSum1 = function (numbers, target) {
				let index;
				let i = 0;

				for (i; i < numbers.length; i++) {

					let newTarget = target - numbers[i];
					index = binarySearch2(numbers.slice(i + 1), newTarget);
					if (index !== undefined) {
						return [i + 1, index + i + 2]
					}
				}
			}

			//twoSum([5,25,75],100)

			// case:[0,0,3,4]
			// case [5,25,75]

			//167. Two Sum II - Input array is sorted
			// array.indexOf
			const twoSum = function (numbers, target) {

				// two pointers
				// indexOf()

			}


			//344. Reverse String
			const reverseString = function (s) {
				let left = 0;
				let right = s.length - 1

				while (left <= right) {
					[s[left], s[right]] = [s[right], s[left]];
					left++;
					right--
				}

				return s // if or not retun matters // swap change the original array
			};

			//557. Reverse Words in a String III
			const reverseWords1 = function (s) {
				let splited = s.split('');
				let reveresed = [];

				let slow = 0; let fast = 0;
				while (splited.length > 0) {


					if (splited[fast] !== ' ' && fast <= splited.length) {
						fast++
					} else {
						let tempt = splited.splice(slow, fast);
						reverseString(tempt);
						reveresed = reveresed.concat(tempt);
						if (splited.length) {
							reveresed = reveresed.concat(splited.shift())
						};
						slow = 0;
						fast = 0;
					}
				}

				return reveresed.join('');

			};



			const reverseWords2 = function (s) {
				// js array.split(' ') seperate the words by white space
				let words = s.split(' ');
				let res = []
				words.forEach(word => {
					let reversed = reverseString(word.split(''));
					res.push(reversed.join(''))
				});

				return res.join(' ')

			}


			var reverseWords = function (s) {
				let arr = s.split("").reverse().join("")
				return arr.split(" ").reverse().join(" ")
			};
			//reverseWords("Let's take LeetCode contest")


			function ListNode(val, next) {
				this.val = (val === undefined ? 0 : val)
				this.next = (next === undefined ? null : next)
			}

			//19. Remove Nth Node From End of List
			const removeNthFromEnd = function (head, n) {
				let dumpy = new ListNode(null);  // for the case you need delete the first element of head
				dumpy.next = head;

				let fast = dumpy;
				let slow = dumpy;


				while (n > 0) {
					fast = fast.next;
					if (fast.next === null) {
						//fast.next = slow   ===> this will cause the list be endless
					}
					n--
				};

				while (fast.next) { // if fast.next === null, the Boolean value is false, won't go inside while
					fast = fast.next;
					slow = slow.next;
				};

				slow.next = slow.next.next;

				console.log(dumpy.next)
				return dumpy.next;

			};

			const mylist = {
				val: 4,
				next: {
					val: 5,
					next: {
						val: 1,
						next: {
							val: 9,
							next: null
						}
					}
				}
			}

			const tc2 = {
				val: 1,
				next: {
					val: 2,
					next: null
				}
			};

			const tc1 = {
				val: 1,
				next: null
			};

			//removeNthFromEnd(tc2, 2)
			//removeNthFromEnd(tc1, 1)


			// 滑动窗口
			//3. Longest Substring Without Repeating Characters
			const lengthOfLongestSubstring1 = function (s) {

				let maxLength = 0;

				if (s.length <= 1) return s.length;

				for (let slow = 0, fast = 1; fast < s.length;) {
					//between the slow and fast 在快慢指针之间，如果当前fast的指向的字母在这个区间出现过
					for (let i = slow; i < fast; i++) {
						if (s[i] === s[fast]) {
							slow = i + 1;  //slow 指向重复字母的下一个；
						};
					}

					//console.log(slow,fast);
					maxLength = Math.max(maxLength, fast - slow + 1);
					fast++; // move one to the right

				}

				return maxLength;

			};


			function lengthOfLongestSubstring(s) {
				let len = s.length;
				let result = 0;

				for (let i = 0; i < len; i++) {
					let set = new Set();
					let maxLen = 0;
					// 从i的位置遍历得到最长子串的长度
					let j = i;
					while (j < len && !set.has(s[j])) { //如果出现已出现的值，就不再进入while
						set.add(s[j]);
						maxLen++;
						j++;
					}
					// 取历史最大值 此时说明发现重复值了，计算当前的长度，然后更新i
					result = Math.max(result, maxLen);
				}
				return result;
			}

			//lengthOfLongestSubstring('abcafe')

			//567. Permutation in String
			const checkInclusion1 = function (s1, s2) {
				let s1Set = new Set();
				for (let i = 0; i < s1.length; i++) {
					s1Set.add(s1[i])
				};

				for (let i = 0; i < s2.length; i++) {
					let set2 = new Set(s1Set);
					for (let j = i; j < i + s1.length; j++) {
						if (!set2.has(s2[j])) break;
						if (set2.has(s2[j])) {
							set2.delete(s2[j])
						};
						if (set2.size === 0) return true
					}
				}

				return false

			};

			//checkInclusion( "ab", "eidbaooo")
			//checkInclusion("hello","ooolleoooleh")  // couln't pass this one, as A value in the Set may only occur once; 

			const checkInclusion = function (s1, s2) {
				let set1 = new Map();
				for (let i = 0; i < s1.length; i++) {
					if (set1.has(s1[i])) {
						let val = set1.get(s1[i]);
						set1.set(s1[i], ++val)
					} else {
						set1.set(s1[i], 1)
					}

				};

				for (let i = 0; i < s2.length; i++) {
					let set2 = new Map(set1);
					let resArr = [];
					for (let j = i; j < i + s1.length; j++) {
						if (!set2.has(s2[j])) break;
						if (set2.has(s2[j])) {
							let val = set2.get(s2[j]);
							set2.set(s2[j], --val)
						};
						//if(set2.size === 0 ) return true
						for (const value of set2.values()) {
							resArr.push(value);
						}
						if (resArr.every(value => value === 0)) {
							return true
						}
						resArr = [];
					}
				}

				return false

			};

			//checkInclusion("hello","ooolleoooleh")   /// 

			//733. Flood Fill DFS
			const floodFill = function (image, sr, sc, newColor) {
				if (image[sr][sc] === newColor) {
					return image;
				}

				const oldColor = image[sr][sc];

				const dfs = (sr, sc) => {
					if (
						sr < 0 ||
						sc < 0 ||
						sr >= image.length ||
						sc >= image[0].length ||
						image[sr][sc] !== oldColor
					) {
						return;
					}

					image[sr][sc] = newColor;

					dfs(sr - 1, sc);
					dfs(sr + 1, sc);
					dfs(sr, sc - 1);
					dfs(sr, sc + 1);
				}

				dfs(sr, sc);
				return image

			};


			//617. Merge Two Binary Trees
			const mergeTrees1 = function (root1, root2) {
				if (root1 == null && root2) {
					return root2
				}
				if ((root1 && root2 == null) || (root1 == null && root2 == null)) {
					return root1
				}

				root1.val += root2.val;


				root1.left = mergeTrees(root1.left, root2.left);
				root1.right = mergeTrees(root1.right, root2.right);

				return root1
			};

			const mergeTrees = function (root1, root2) {
				//递归出口
				if (!root1) return root2;
				if (!root2) return root1;

				root1.val += root2.val;

				//recursion
				root1.left = mergeTrees(root1.left, root2.left);
				root1.right = mergeTrees(root1.right, root2.right);

				return root1;
			}

			//116. Populating Next Right Pointers in Each Node
			/**
				* // Definition for a Node.
				* function Node(val, left, right, next) {
			*    this.val = val === undefined ? null : val;
				*    this.left = left === undefined ? null : left;
			*    this.right = right === undefined ? null : right;
				*    this.next = next === undefined ? null : next;
				* };
				*/

			/**
			 * @param {Node} root
			 * @return {Node}
			 */
			//BFS
			const connect1 = function (root) {
				let queue = [];

				if (root) queue.push(root);

				while (queue.length > 0) {
					let levelSize = queue.length;

					while (levelSize > 0) {
						let node = queue.shift();
						levelSize--;

						//左右节点入列
						if (node.left) queue.push(node.left);
						if (node.right) queue.push(node.right);

						//当前层最后一个节点指向next指向null
						if (levelSize === 0) node.next = null;

						if (levelSize > 0) node.next = queue[0]
					}
				};

				return root

			};


			//DFS
			const connect2 = function (root) {
				if (root == null || root.left == null) {
					return root;
				}
				root.left.next = root.right;//(修改当前的下一层)
				root.right.next = root.next === null ? null : root.next.left //(修改当前的下下层)
				root.left = connect(root.left);
				root.right = connect(root.right);

				return root;
			}

			//不需要修改每层最后一个节点的Next,因为它本来就定义为null
			const connect = function (root) {
				if (root === null) return root;

				const dfs = (node) => {
					if (node.left === null && node.right === null) return; // leaf node

					node.left.next = node.right;
					if (node.next) node.right.next = node.next.left; // node.next在上一层已经被修改

					dfs(node.left); // depth first 左枝一直前进到叶子节点
					dfs(node.right);

				}

				dfs(root);
				return root;

			}

			//542. 01 Matrix
			const updateMatrix = function (mat) {
				const m = mat.length;
				const n = mat[0].length;
				let dp = new Array(m).fill(0).map(i => new Array(n));  // empty two-D array

				for (let i = 0; i < m; i++) {
					for (let j = 0; j < n; j++) {
						dp[i][j] = mat[i][j] === 0 ? 0 : 10000
					}
				} // 如果matrix是零，那么该格子值就是0

				for (let i = 0; i < m; i++) {
					for (let j = 0; j < n; j++) {
						if (i >= 1) {
							dp[i][j] = Math.min(dp[i][j], dp[i - 1][j] + 1)
						}
						if (j >= 1) {
							dp[i][j] = Math.min(dp[i][j], dp[i][j - 1] + 1)
						}
					}
				}

				for (let i = m - 1; i >= 0; i--) {
					for (let j = n - 1; j >= 0; j--) {
						if (i + 1 < m) {
							dp[i][j] = Math.min(dp[i][j], dp[i + 1][j] + 1);
						}
						if (j + 1 < n) {
							dp[i][j] = Math.min(dp[i][j], dp[i][j + 1] + 1);
						}
					}
				}

				return dp

			}


			// 994. Rotting Oranges
			const orangesRotting = function (grid) {
				const m = grid.length;
				const n = grid[0].length;
				let queue = [];
				let sum = 0;
				let res = 0;

				for (let i = 0; i < m; i++) {
					for (let j = 0; j < n; j++) {
						if (grid[i][j] === 2) {
							queue.push([i, j])
						} else if (grid[i][j] === 1) {
							sum++
						}
					}
				}

				if (sum === 0) return res;

				while (sum > 0 && queue.length) {
					let levelSize = queue.length;
					res++;

					while (levelSize > 0) {
						let node = queue.shift();
						let row = node[0];
						let col = node[1];

						//left
						if (row - 1 >= 0 && grid[row - 1][col] === 1) {
							grid[row - 1][col] = 2;
							queue.push([row - 1, col]);
							sum--;
						};
						//right
						if (row + 1 < m && grid[row + 1][col] === 1) {
							grid[row + 1][col] = 2;
							queue.push([row + 1, col]);
							sum--;
						};
						//up
						if (col - 1 >= 0 && grid[row][col - 1] === 1) {
							grid[row][col - 1] = 2;
							queue.push([row, col - 1]);
							sum--
						};
						//bottom
						if (col + 1 < n && grid[row][col + 1] === 1) {
							grid[row][col + 1] = 2;
							queue.push([row, col + 1]);
							sum--
						}
						levelSize--;
					}
				};// end while

				/*	if (sum > 0) {
						return -1
					} else {
						return res
					}
				*/

				return sum > 0 ? -1 : res
			};

			//orangesRotting([[2, 1, 1], [1, 1, 0], [0, 1, 1]])
			//orangesRotting([[1,2]])

			//24. Swap Nodes in Pairs
			const swapPairs = function (head) {
				let dumpH = new ListNode(null);
				dumpH.next = head;

				while (head.next) {
					let tmp = head.next;


				}
			}


			//08.06 hanota
			const hanota = function (A, B, C) {
				let source;
				source = source === A ? B : A
				let tmp;
				tmp = tmp === B ? A : B

				let toBeMoved = source.splice(1);
				hanota(toBeMoved, tmp, C);
				C.push(source.pop())

				return C

			};

			//217
			const containsDuplicate1 = function (nums) {
				for (let i = 0; i < nums.length; i++) {
					for (let j = i + 1; j < nums.length; j++) {
						if (nums[i] === nums[j]) return true
					}
				}
				return false
			};

			const containsDuplicate = function (nums) {
				let numSet = new Set();
				for (let i = 0; i < nums.length; i++) {
					if (!numSet.has(nums[i])) {
						numSet.add(nums[i])
					} else {
						return true
					}
				};

				return false
			}

			// another solution : sort the array first

			//26. 删除有序数组中的重复项 26. Remove Duplicates from Sorted Array
			const removeDuplicates = function (nums) {
				for (var i = 0, j = i + 1; j < nums.length;) {
					if (nums[i] === nums[j]) {
						j++
					} else {
						[nums[i + 1], nums[j]] = [nums[j], nums[i + 1]]; //swap i+1 and j
						i++;
						j++;
						//console.log('i',i)
					}
				}

				return i + 1

			};

			//removeDuplicates([0, 0, 1, 1, 1, 2, 2, 3, 3, 4])

			//53. Maximum Subarray
			var maxSubArray = function (nums) {

			};

			//88. Merge Sorted Array
			const merge1 = function (nums1, m, nums2, n) {
				let i = 0, j = 0;

				while (j < n && m <= nums1.length) {
					if (nums1[i] <= nums2[j]) {
						i++
					} else {    // nums1[i] > nums2[j]  insert nums2[j]
						// 先把需要插入的数 放入nums1中
						nums1[m] = nums2[j];

						// 把该数交换到 i 的位置 需要交换 m - i 次
						let cur = m;
						while (cur > i) {  // between i and current m
							if (nums1[cur] < nums1[cur - 1]) {
								[nums1[cur - 1], nums1[cur]] = [nums1[cur], nums1[cur - 1]];
								cur--

							}
						}
						m++; // m 指向下一个空 0
						i++;
						j++;
					}
				}
			};

			// use array.sort() directly
			const merge2 = function (nums1, m, nums2, n) {
				// put nums2 at the tail of nums1
				for (let i = 0; i < n; i++) {
					nums1[m + i] = nums2[i]
				}

				//  nums1.splice(m, nums1.length - m, ...nums2);

				nums1.sort((a, b) => a - b)
			}
			//merge([1,2,3,0,0,0],3,[2,5,6],3)

			// quick sort nums1 [1, 2, 3, 2, 5, 6], the pilot start from m-1
			const quickSort = function (nums, i, j) {
				// 需要再增加一个限制条件，否则会无限循环  j=-1 ...
				if (i < j) {   // ?
					let index = i;
					let pilot = nums[index];

					while (i <= j) {
						if (nums[i] <= pilot) {
							i++;
							continue;
						};
						if (nums[j] > pilot) {
							j--;
							continue;
						};

						[nums[i], nums[j]] = [nums[j], nums[i]];
					}
					[nums[index], nums[j]] = [nums[j], nums[index]]; // pilot 归位

					quickSort(nums, 0, j - 1);
					quickSort(nums, j, nums.length - 1)
				}


			};

			//quickSort(nums, 0, nums.length-1)
			//quickSort([7, 5, 8, 1, 6, 3, 9], 0, 6)


			// 349  Intersection of Two Arrays (unique)
			// if two for loop, the time is O(m*n)
			// if use two set, the time is O(m+n)

			const intersection = function (nums1, nums2) {
				let set1 = new Set();
				let set2 = new Set();
				nums1.forEach(num => set1.add(num));
				nums2.forEach(num => set2.add(num));

				const getIntersection = function (set1, set2) { //set1 is shorter
					let res = [];
					for (const num of set1) {
						if (set2.has(num)) {
							res.push(num);
						}
					}
					return res;
				}

				return set1.size < set2.size       // size matters
					? getIntersection(set1, set2)
					: getIntersection(set2, set1)
			}


			//350. Intersection of Two Arrays II   the solution is not completely correct 09/12/2021

			const getIntersection = function (arr1, arr2) {   // arr1 is shorter
				let res = new Map();
				for (let i = 0; i < arr1.length; i++) {
					for (let j = 0; j < arr2.length; j++) {
						if (arr1[i] === arr2[j]) {
							res.set(i, arr1[i]);
						}
					}
				}
				console.log(res);
				return Array.from(res.values());
			}

			const intersect = function (nums1, nums2) {
				return nums1.length <= nums2.length
					? getIntersection(nums1, nums2)
					: getIntersection(nums2, nums1)
			};

			//intersect([4,9,5],[9,4,9,8,4])


			//121. Best Time to Buy and Sell Stock
			// run out of time 暴力解法
			const maxProfit1 = function (prices) {
				let profit = 0;
				for (let i = 0; i < prices.length;) {
					if (prices[i] > prices[i + 1]) {
						i++
					}
					for (let j = i + 1; j < prices.length; j++) {
						profit = Math.max(profit, prices[j] - prices[i])
					}
					i++
				}

				return profit
			};

			//单调栈   minstack
			const maxProfit2 = function (prices) {
				let minStack = [];
				let max = 0;
				prices.push(0);

				for (const price of prices) {

					while (minStack.length > 0 && price <= minStack[minStack.length - 1]) { // 弹出直到当前栈底为最小元素
						max = Math.max(max, minStack[minStack.length - 1] - minStack[0]);
						minStack.pop(); // 弹出栈顶元素 5;
					}

					minStack.push(price);
				}

				return max;
			};

			//Greedy  Time O(n)  Space O(1);
			const maxProfit3 = function (prices) {
				let low = prices[0]; // low need to have a value to make sure Math.min() works
				let res = 0;
				for (const price of prices) {
					low = Math.min(low, price);
					res = Math.max(res, price - low)
				}
				return res;
			}

			//DP
			const maxProfit = function (prices) {
				let pre = 0;
				let res = 0;

				for (let i = 1; i < prices.length; i++) {
					let diff = prices[i] - prices[i - 1];

					// maxProfit(i) = maxprofit(i-1) + diff
					pre = Math.max(pre + diff, 0);
					res = Math.max(res, pre)
				}

				return res

			}


			//maxProfit([7,1,5,3,6,4])
			//maxProfit([2,1,2,1,0,1,2]);
			//maxProfit([3, 3, 5, 0, 0, 3, 1, 4])

			//dp
			const maxProfitII2 = function (prices) {
				let len = prices.length;
				let dp = new Array(len).fill(0).map(item => new Array(len));
				//dp[0][0] = 0;

				for (let i = 0; i < len; i++) {
					for (let j = i + 1; j < len; j++) {
						dp[i][i] = 0;
						dp[i][j] = Math.max(dp[i][j - 1], prices[j] - prices[i])
					}
				};

				console.log(dp)

			};

			//greedy
			const maxProfitII = function (prices) {
				// 在所有上涨交易日都做买卖，在所有下跌交易日都不做买卖
				let temp;
				let profit = 0;
				for (let i = 1; i < prices.length; i++) {
					temp = prices[i] - prices[i - 1];
					if (temp > 0) {
						profit += temp;
					}
				};
				return profit;
			}

			//566. Reshape the Matrix
			const matrixReshape = function (mat, r, c) {
				let m = mat.length; //row 
				let n = mat[0].length; //column

				//if(m*n !== r*c) return mat;
				//let res = new Array(r).fill(0).map(item => new Array(c));
				let res = new Array(r).fill(0);

				for (let i = 0, j = 0; i < m, j < r;) {

					if (c >= n) {             //新的数组宽
						res[j] = [...mat[i]]
					}

				}

			};

			//118. Pascal's Triangle
			const generate = function (numRows) {
				let res = new Array(numRows)
					.fill(0)
					.map((item, i) => new Array(i + 1));

				for (let i = 0; i < numRows; i++) {
					for (let j = 0; j <i+1; j++) {
						if (j === 0 || j === res[i].length - 1) {
							res[i][j] = 1;
						} else {
							res[i][j] = res[i - 1][j - 1] + res[i - 1][j]
						}
					}
				}
				//console.log(res)
				return res;
			};


		</script>

	</body>

	</html>