<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title></title>
</head>

<body>
    <script type="text/javascript">
        //1. two sum
        // 坑1： 原始数组中可能出现重复的数字，比如[3,3], target=6；
        // 坑2： 返回的是Index，所以如果对原始排序，要注意保留之前的顺序。
        // 坑3： 数字可能会是负数，负数的指针操作跟正数不一样。
        /*
        const twoSum = function (numbers, target) {
            let result= [];
            let copyNum = [...numbers].sort((a,b) => a-b);

           let left=0;
           let right=numbers.length-1; 

           while(left<right) {
               if(copyNum[left]+copyNum[right] > target) {
                   right--;
               } else if(copyNum[left] + copyNum[right] < target) {
                   left++;
               } else {
                   let firstIdx = numbers.indexOf(copyNum[left]); 
                   let secondIdx = numbers.indexOf(copyNum[right], firstIdx+1); // 2nd params: start from index
                   result.push(firstIdx);
                   result.push(secondIdx);
                   break;
               }
           };

           return result; // return the orginal index in numbers array; 
        };
        */

        //for 暴力解法
        const twoSum = function (numbers, target) {
            const result = [];
            for (let i = 0; i < numbers.length - 1; i++) {
                for (let j = i + 1; j < numbers.length; j++) {
                    if (numbers[i] + numbers[j] === target) {
                        result.push(i);
                        result.push(j);
                    }
                }
            };
            return result;
        };

        // harsh map for key-value pair  num -> index
        const twoSumSet = function (numbers, target) {
            const result = [];
            const harshMap = new Map();

            for (let i = 0; i < numbers.length; i++) {
                const newTarget = target - numbers[i];
                let j = harshMap.get(newTarget);
                harshMap.set(numbers[i], i);
                if (j !== undefined && j !== i) {
                    result.push(i);
                    result.push(j);
                }
            };
            return result;
        };

        //2. Add Two Numbers
        const list1 = {
            val: 2,
            next: {
                val: 4,
                next: {
                    val: 3,
                    next: {
                        val: 8,
                        next: null
                    }
                }
            }
        };

        const list2 = {
            val: 5,
            next: {
                val: 6,
                next: {
                    val: 4,
                    next: null
                }
            }
        };

        function ListNode(val, next) {
            this.val = (val === undefined ? 0 : val)
            this.next = (next === undefined ? null : next)
        };


        const addTwoNumbers = function (l1, l2) {
            let Dumhead = new ListNode();
            let cur = Dumhead;

            let add = 0;

            while (l1 || l2) {
                l1 ? value1 = l1.val : value1 = 0;
                l2 ? value2 = l2.val : value2 = 0;

                let sum = value1 + value2 + add;
                add = Math.floor(sum / 10); // 进位值
                sum = sum % 10; // 当前值

                if (l1) { l1 = l1.next }; // 这里是if里是l1, 如果是l1.next的话，指针就动不了了
                if (l2) { l2 = l2.next };

                cur.next = new ListNode(sum);
                cur = cur.next;
            };

            if (add === 1) {
                cur.next = new ListNode(add)
            }

            return Dumhead.next;
        };

        // addTwoNumbers(list1, list2);

        //剑指 Offer II 091. 粉刷房子
        // 基本思路对，因为房子只有3种可能的颜色，所以算每行的最小值，不必这么复杂。
        const minCost = function (costs) {
            const m = costs.length;
            const n = costs[0].length;

            const dp = new Array(m).fill(0).map(item => new Array(n).fill(0));
            dp[0] = costs[0];
            let min = rowMin(dp[0]);
            let pre_index = dp[0].indexOf(min);

            for (let i = 1; i < m; i++) {
                for (let j = 0; j < n; j++) {
                    dp[i][j] = j === pre_index ? costs[i][j] + rowMin(dp[i - 1], pre_index) : costs[i][j] + min;
                };

                min = rowMin(dp[i]);
                pre_index = dp[i].indexOf(min);
            };
            console.log(dp);

            return min;
        };

        const rowMin = function (arr, index) {
            let min = 100;
            for (let i = 0; i < arr.length; i++) {
                if (i === index) {
                    continue;
                } else {
                    min = Math.min(min, arr[i]);
                }
            };
            return min;
        };

        // minCost([[17,2,17],[16,16,5],[14,3,19]]);

        //22.括号生成
        const generateParenthesis = n => {
            if (!n) return [''];
            const res = [];

            const dfs = (path, left, right) => {
                // 去除无效括号
                // 左括号不能过半，右括号数量不能超过左括号
                if (left > n || right > left) return;
                //生成n对有效括号
                if (path.length === 2 * n) {
                    res.push(path);
                    return;
                };
                //追加左括号
                dfs(`${path}(`, left + 1, right);
                //追加右括号
                dfs(`${path})`, left, right + 1);
            };

            dfs('', 0, 0);
            return res;
        };

        //143 重排链表
        // 找到链表的中点，把后半段反转，然后拼接在一起
        const reverseLinkedList = head => {
            let pre = null;
            while (head) {
                let tmp = head.next;
                head.next = pre;
                pre = head;
                head = tmp;
            };

            return pre;
        };

        // reverseLinkedList(list1);

        const reorderList = function (head) {
            let fast = head;
            let slow = head;

            let dumh = new ListNode();
            dumh.next = head;

            while (fast.next.next) {
                fast = fast.next.next;
                slow = slow.next;
            };

            let firstHalfLastNode = slow;
            let secondHalf = reverseLinkedList(fast);

            while(secondHalf) {
                let tmp1 = head.next;
                head.next = secondHalf;
                secondHalf = secondHalf.next;
                head = head.next;
                head.next = tmp1;   
                head=head.next;  
                if(head.val===slow.val) break;          
            };

            return dumh.next;
        };

        reorderList(list1);




    </script>

</body>

</html>