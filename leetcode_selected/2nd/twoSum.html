<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title></title>
</head>

<body>
    <script type="text/javascript">
        //1. two sum
        // 坑1： 原始数组中可能出现重复的数字，比如[3,3], target=6；
        // 坑2： 返回的是Index，所以如果对原始排序，要注意保留之前的顺序。
        // 坑3： 数字可能会是负数，负数的指针操作跟正数不一样。
        /*
        const twoSum = function (numbers, target) {
            let result= [];
            let copyNum = [...numbers].sort((a,b) => a-b);

           let left=0;
           let right=numbers.length-1; 

           while(left<right) {
               if(copyNum[left]+copyNum[right] > target) {
                   right--;
               } else if(copyNum[left] + copyNum[right] < target) {
                   left++;
               } else {
                   let firstIdx = numbers.indexOf(copyNum[left]); 
                   let secondIdx = numbers.indexOf(copyNum[right], firstIdx+1); // 2nd params: start from index
                   result.push(firstIdx);
                   result.push(secondIdx);
                   break;
               }
           };

           return result; // return the orginal index in numbers array; 
        };
        */

        //for 暴力解法
        const twoSum = function (numbers, target) {
            const result = [];
            for (let i = 0; i < numbers.length - 1; i++) {
                for (let j = i + 1; j < numbers.length; j++) {
                    if (numbers[i] + numbers[j] === target) {
                        result.push(i);
                        result.push(j);
                    }
                }
            };
            return result;
        };

        // harsh map for key-value pair  num -> index
        const twoSumSet = function (numbers, target) {
            const result = [];
            const harshMap = new Map();

            for (let i = 0; i < numbers.length; i++) {
                const newTarget = target - numbers[i];
                let j = harshMap.get(newTarget);
                harshMap.set(numbers[i], i);
                if (j !== undefined && j !== i) {
                    result.push(i);
                    result.push(j);
                }
            };
            return result;
        };

        //2. Add Two Numbers
        const list1 = {
            val: 2,
            next: {
                val: 4,
                next: {
                    val: 3,
                    next: {
                        val: 8,
                        next: null
                    }
                }
            }
        };

        const list2 = {
            val: 5,
            next: {
                val: 6,
                next: {
                    val: 4,
                    next: null
                }
            }
        };

        function ListNode(val, next) {
            this.val = (val === undefined ? 0 : val)
            this.next = (next === undefined ? null : next)
        };


        const addTwoNumbers = function (l1, l2) {
            let Dumhead = new ListNode();
            let cur = Dumhead;

            let add = 0;

            while (l1 || l2) {
                l1 ? value1 = l1.val : value1 = 0;
                l2 ? value2 = l2.val : value2 = 0;

                let sum = value1 + value2 + add;
                add = Math.floor(sum / 10); // 进位值
                sum = sum % 10; // 当前值

                if (l1) { l1 = l1.next }; // 这里是if里是l1, 如果是l1.next的话，指针就动不了了
                if (l2) { l2 = l2.next };

                cur.next = new ListNode(sum);
                cur = cur.next;
            };

            if (add === 1) {
                cur.next = new ListNode(add)
            }

            return Dumhead.next;
        };

        // addTwoNumbers(list1, list2);

        //剑指 Offer II 091. 粉刷房子
        // 基本思路对，因为房子只有3种可能的颜色，所以算每行的最小值，不必这么复杂。
        const minCost = function (costs) {
            const m = costs.length;
            const n = costs[0].length;

            const dp = new Array(m).fill(0).map(item => new Array(n).fill(0));
            dp[0] = costs[0];
            let min = rowMin(dp[0]);
            let pre_index = dp[0].indexOf(min);

            for (let i = 1; i < m; i++) {
                for (let j = 0; j < n; j++) {
                    dp[i][j] = j === pre_index ? costs[i][j] + rowMin(dp[i - 1], pre_index) : costs[i][j] + min;
                };

                min = rowMin(dp[i]);
                pre_index = dp[i].indexOf(min);
            };
            console.log(dp);

            return min;
        };

        const rowMin = function (arr, index) {
            let min = 100;
            for (let i = 0; i < arr.length; i++) {
                if (i === index) {
                    continue;
                } else {
                    min = Math.min(min, arr[i]);
                }
            };
            return min;
        };

        // minCost([[17,2,17],[16,16,5],[14,3,19]]);

        //22.括号生成
        const generateParenthesis = n => {
            if (!n) return [''];
            const res = [];

            const dfs = (path, left, right) => {
                // 去除无效括号
                // 左括号不能过半，右括号数量不能超过左括号
                if (left > n || right > left) return;
                //生成n对有效括号
                if (path.length === 2 * n) {
                    res.push(path);
                    return;
                };
                //追加左括号
                dfs(`${path}(`, left + 1, right);
                //追加右括号
                dfs(`${path})`, left, right + 1);
            };

            dfs('', 0, 0);
            return res;
        };

        //143 重排链表
        // 找到链表的中点，把后半段反转，然后拼接在一起
        const reverseLinkedList = head => {
            let pre = null;
            while (head) {
                let tmp = head.next;
                head.next = pre;
                pre = head;
                head = tmp;
            };

            return pre;
        };

        const middleNode = function (head) {
            let slow = head;
            let fast = head;

            while (fast !== null && fast.next != null) {
                slow = slow.next;
                fast = fast.next.next;
            }

            return slow;
        };

        const mergeLinkedList = (list1, list2) => {
            while (list1 && list2) {
                let tmp1 = list1.next;
                let tmp2 = list2.next;

                list1.next = list2;
                list1 = tmp1;

                list2.next = list1;
                list2 = tmp2;

            }
        };

        const reorderList = function (head) {
            if (head === null) return;

            let midNode = middleNode(head);
            let l1 = head;
            let l2 = midNode.next;
            midNode.next = null;// 截断left部分
            l2 = reverseLinkedList(l2);

            mergeLinkedList(l1, l2)
        };

        // 思路2 存入数组
        const reorderList2 = head => {
            if (!head) return null;
            let dumh = head;
            const listArr = [];

            while (dumh) {
                listArr.push(dumh);
                dumh = dumh.next;
            };

            let left = 1, right = listArr.length - 1;

            while (left <= right) {
                head.next = listArr[right];
                right--;
                head = head.next;
                head.next = listArr[left];
                left++;
                head = head.next;
            }

            head.next = null;
        };


        //31. Next Permutation
        //12385764 --12386457
        //12 - 21        

        const nextPermutation = function (nums) {
            if (nums.length === 1) return nums;
            let i = nums.length - 2;

            for (i; i >= 0; i--) {
                let cur = nums[i];
                let next = nums[i + 1];
                if (cur < next) {
                    break;
                };
            }
            let start = 0;
            if (i !== 0) {
                let k = nums.length - 1;
                for (k; k >= i + 1; k--) {
                    if (nums[k] > nums[i]) break;
                };

                // swap i and k
                [nums[i], nums[k]] = [nums[k], nums[i]];
                start = i + 1;
            }

            // reorder i+1 to end; bubble
            for (let l = start; l < nums.length; l++) {
                for (let j = l + 1; j < nums.length - l; j++) {
                    if (nums[l] > nums[j]) {
                        [nums[l], nums[j]] = [nums[j], nums[l]]
                    };
                }
            };

            return nums;
        };


        // 912 sort array
        // 1. merge sort 
        //执行用时：4580 ms,在所有 JavaScript 提交中击败了17.28%的用户
        const _mergeArray = (a, b) => {
            const c = [];

            while (a.length && b.length) {
                c.push(a[0] > b[0] ? b.shift() : a.shift())
            };

            // a might not be equal length with b
            while (a.length) {
                c.push(a.shift());
            };

            while (b.length) {
                c.push(b.shift())
            };

            return c;
        }
        sortArray = function (nums) {
            if (nums.length === 1) return nums;

            const middle = Math.floor(nums.length / 2);
            const nums_l = nums.slice(0, middle);
            const nums_r = nums.slice(middle);

            return _mergeArray(sortArray(nums_l), sortArray(nums_r));
        };

        // 2.quick sort

        // 复习基础排序算法
        // leetcode 排序题

        //如何把数组2快速复制到数组1的后半段
        // 而不是一个个Push进去
        const copytoTail = (nums1, m, nums2, n) => {
            // array.splice replace item 
            nums1.splice(m, nums1.length - m, ...nums2)
        };


        // 88 merge sort88. 合并两个有序数组
        // 这个思路就是双指针，从前往后插， 因为可能会覆盖原有元素，所以得把它保存在临时变量里。
        // 以下写法过不了corner cases
        const merge = function (nums1, m, nums2, n) {
            let tmp;
            if (m === 0) {
                nums1 = nums2;
            } else {
                for (let i = 0, j = 0; i < m + n, j < n; i++) {
                    if (nums1[i] > nums2[j]) {
                        tmp = nums1[i];
                        nums1[i] = nums2[j];
                        j++;
                    }
                };
            }
        };

        // 双指针从后往前排，先把大的放在最后

        //27 remove element in array 数组移除元素

        const removeElement = function (nums, val) {
            // let has block scope, can not be access if defined within for loop;
            let j = nums.length - 1;

            // key point; i<=j; 当i=j时，同时指向同一个元素，如果该元素是target，交换就等于没交换，但是关键点是j的值会减1.
            for (let i = 0; i <= j; i++) {
                if (nums[i] === val) {
                    [nums[i], nums[j]] = [nums[j], nums[i]];
                    i--; // 可能是target元素被交换过来，所以再减1重新判断一次。
                    j--;
                };
            };

            return j + 1;

        };
        // removeElement([0,1,2,2,3,0,4,2],2);
        //removeElement([1],1); // i=j， 交换，j-- 值为-1。

        //快慢双指针法
        const removeElementTwoPointers = (nums, val) => {
            let fast = 0;
            let slow = 0;

            for (fast, slow; fast < nums.length;) {
                if (nums[fast] === val) {
                    fast++;
                } else {
                    // when fast and slow point to diff items, swap 
                    if (fast !== slow) {
                        [nums[slow], nums[fast]] = [nums[fast], nums[slow]];
                    };
                    fast++;
                    slow++;
                }
            };

            return slow;
        };

        // 简单写法
        const removeElementTwoPointers2 = (nums, val) => {
            let fast = 0;
            let slow = 0;

            for (fast, slow; fast < nums.length; fast++) {
                if (nums[fast] !== val) {
                    [nums[slow], nums[fast]] = [nums[fast], nums[slow]];
                    slow++;
                }
            };

            return slow;
        };

        // removeElementTwoPointers([0,1,2,2,3,0,4,2],2)

        //977 有序数组的平方
        //首位双指针； 另外一种解法是借用stack，存入负值的平方，然后push正值平方时，每次跟栈首元素对比。
        const sortedSquares = function (nums) {
            let i = 0;
            let j = nums.length - 1;
            let res = [];

            for (i, j; i <= j;) {   // i=j， push the last element otherwise res will miss one element in the middle of nums.
                if (Math.abs(nums[i]) > Math.abs(nums[j])) {
                    res.unshift(nums[i] * nums[i]);
                    i++
                } else {
                    res.unshift(nums[j] * nums[j]);
                    j--;
                };
            };
            return res;
        };

        //  sortedSquares([-4,-1,0,3,10]); // return [0,1,9,16,100]

        // 209 长度最小的数组   和>=target长度最小的数组
        // solution 1: 暴力解法    时间复杂度O(N*N)
        const minSubArrayLen = function (target, nums) {
            let minLen = nums.length;
            let flag = false;

            for (let i = 0; i < nums.length; i++) {
                let curSum = nums[i];
                if (curSum >= target) {
                    flag = true;
                    minLen = 1;
                    break;
                } else {
                    for (let j = i + 1; j < nums.length; j++) {
                        curSum += nums[j]
                        if (curSum >= target) {
                            flag = true;
                            minLen = Math.min(minLen, j - i + 1)
                        };
                    }
                }

            };

            return flag === true ? minLen : 0;
        };

        //滑动窗口  双指针，窗口内和如果大于target则左边界缩，若小于则右边界扩张
        // 如果不存在大于target 则返回0
        const minSubArrayLen2 = function (target, nums) {
            let left = 0, right = 0;
            let curSum = nums[0];
            let minLen = nums.length;
            let flag = false;

            for (left, right; right < nums.length;) {
                while (curSum < target) {
                    right++;
                    curSum += nums[right];
                };
                // now curSum >=  target;
                if (curSum >= target) {
                    flag = true;
                    minLen = Math.min(minLen, right - left + 1);
                    curSum -= nums[left];
                    left++;
                }
            };

            return flag === true ? minLen : 0;
        }

        // minSubArrayLen2(7, [2, 3, 1, 2, 4, 3]);
        //target = 7, nums = [2,3,1,2,4,3]

        //219 存在重复元素 II
        //判断数组中是否存在两个不同的索引 i 和 j，使得 nums [i] = nums [j]，并且 i 和 j 的差的 绝对值 至多为 k。
        // 暴力法
        const containsNearbyDuplicate = function (nums, k) {
            // let result = false;
            for (let left = 0; left < nums.length; left++) {
                for (let right = left + 1; right <= left + k; right++) {
                    if (nums[left] === nums[right]) {
                        return true;
                    }
                }
            };

            return false;

        };

        //Map
        const containsNearbyDuplicateMap = function (nums, k) {
            const numMap = new Map();

            for (let i = 0; i < nums.length; i++) {
                if (!numMap.has(nums[i])) {
                    numMap.set(nums[i], i);
                } else {
                    let left = numMap.get(nums[i]);
                    if ((i - left) <= k) return true;
                    numMap.set(nums[i], i);
                }
            };

            return false;
        };

        const containsNearbyDuplicateMap2 = function (nums, k) {
            const numMap = new Map();

            for (let i = 0; i < nums.length; i++) {
                if (numMap.has(nums[i])) {
                    let left = numMap.get(nums[i]);
                    if ((i - left) <= k) return true;
                };
                numMap.set(nums[i], i);
            };

            return false;
        };

        // 滑动窗口+hashMap版   ====》 Map的大小维持在K，一旦超过的话，就删掉最左边的元素

        containsNearbyDuplicateSldingWindow = (nums, k) => {
            const numSet = new Set();

            for (let i = 0; i < nums.length; i++) {
                if (numSet.has(nums[i])) return true;
                numSet.add(nums[i]);

                if (numSet.size > k) {     // 这里是> 不是 >= 因为当1st 和4th item相同的时候，也是符合要求的。
                    numSet.delete(nums[i - k]);
                }
            };

            return false;
        };
        // containsNearbyDuplicateMap([1, 2, 3, 1], 3)
        //nums = [1,2,3,1], k = 3   retur true

        //剑指 Offer II 041. 滑动窗口的平均值
        /**
         * 用队列来维护滑动窗口
         * 
         */
        const MovingAverage = function (size) {
            this.queue = [];
            this.sum = 0;
            this.size = size;

        };

        /** 
         * @param {number} val
         * @return {number}
         */
        MovingAverage.prototype.next = function (val) {
            if (this.queue.length === this.size) {
                let shiftOut = this.queue.shift();
                this.sum -= shiftOut;
            };
            this.queue.push(val);
            this.sum += val;
            return this.sum / this.queue.length;

        };

        /**
         * Your MovingAverage object will be instantiated and called as such:
         * var obj = new MovingAverage(size)
         * var param_1 = obj.next(val)
         */


        //239 Sliding Window Maxium
        // Input: nums = [1,3,-1,-3,5,3,6,7], k = 3
        //Output: [3,3,5,5,6,7]

        // 思路1 双指针暴力解法 
        // 思路2 单调队列  单调递减队列，队首维护最大值，如果新入元素 > 当前队首，则把队列内的全Pop出来再入；
        // 如果新入元素 < 当前队首，则直接入队列。 
        // 队列维护在size K.   how?  queue数组存放下标，通过计算当前元素下标i 与队首（最大值）下标的差值，来判断是否在窗口内。
        //Monotonic Queue
        const maxSlidingWindow = function (nums, k) {
            if (nums.length === 1 || k === 1) return nums;
            const monoQueue = [];
            const result = [];

            for (let i = 0; i < nums.length; i++) {
                // queue is not empty; cur item > queue tail items
                while (monoQueue.length && nums[i] > nums[monoQueue[monoQueue.length - 1]]) {
                    monoQueue.pop();
                };

                // push index; the real item can be access by index at nums. 
                monoQueue.push(i);

                // shift queue head
                while (i - monoQueue[0] >= k) {
                    monoQueue.shift();
                };

                // push from the k-1 times.
                if (i >= k - 1) {
                    result.push(nums[monoQueue[0]]);
                }
            };

            return result;
        };

        //maxSlidingWindow([1,3,-1,-3,5,3,6,7],3);
        // maxSlidingWindow([7, 2, 4], 2);

        //541. Reverse String II
        // string can not be update with index; should transfer to array.
        const reverseStr = function (s, k) {
            if (s.length === 1 || k === 1) return s;
            let sArr = s.split('');

            let slow = 0, fast = 0;
            let times = 1;
            for (slow, fast; fast < sArr.length;) {
                if (times % 2 === 1) {
                    while (fast < k * times - 1) {
                        fast++;
                    };
                    // reverse [slow, fast]
                    while (slow <= fast) {
                        [sArr[slow], sArr[fast]] = [sArr[fast], sArr[slow]]
                        slow++;
                        fast--;
                    };

                    // reset fast and slow;
                    slow = times * k;
                    fast = times * k;
                    times++;
                } else {
                    while (slow < k * times && fast < k * times) {
                        slow++;
                        fast++
                    };
                    times++
                }
            };

            return sArr.join('');
        };

        const reverseStr2 = function (s, k) {
            const reverse = (arr, left, right) => {
                while (left <= right) {
                    [arr[left], arr[right]] = [arr[right], arr[left]];
                    left++;
                    right--;
                };
            };

            if (s.length === 1 || k === 1) return s;
            let strArr = s.split('');

            const len = s.length;
            for (let l = 0; l < len; l += 2 * k) {
                let r = l + k - 1;
                reverse(strArr, l, Math.min(r, len - 1));
            };

            return strArr.join('');
        };

        //151. Reverse Words in a String
        const reverseWords = function (s) {
            let arr = [];

            for (let i = 0; i < s.length;) {
                if (s[i] === ' ') {
                    i++;
                } else {
                    let j = i;
                    while (s[j] !== ' ' && s[j] !== undefined) {
                        j++
                    };

                    arr.push(s.substring(i, j));
                    console.log(arr);
                    i = j;
                    continue;
                }
            };

            let result = '';
            for (let i = arr.length - 1; i >= 0; i--) {

                result = i === 0 ? result.concat(`${arr[i]}`) : result.concat(`${arr[i]} `);
            };

            return result;
        };

        // 题解思路： 从后向前遍历   待补充

        //reverseWords("the sky is blue");

        //剑指 Offer II 077. 链表排序
        // 用二维数组记录链表节点，[node.val, node];
        // sort the outer array by node.value;
        // dumpy node to store the head?
        const sortList = function (head) {
            const nodeArr = [];

            while (head) {
                //  nodeArr.push([head.val, head]);
                nodeArr.push(head);
                head = head.next;
            };

            // sort nodeArr by node.val;
            // nodeArr.sort((a, b) => a[0] - b[0]);
            nodeArr.sort((a, b) => a.val - b.val)

            for (let i = 0; i < nodeArr.length - 1; i++) {
                nodeArr[i].next = nodeArr[i + 1]
            };
            nodeArr[nodeArr.length - 1].next = null;// 不加这句被提示链表有环
            return nodeArr[0]
        };

        // another solution MergeSort    tobe update
        //sortList(list1);


        // 225 两个队列实现栈
        const MyStack = function () {
            this.queue1 = [];
            this.queue2 = [];
        };

        /** 
         * @param {number} x
         * @return {void}
         */
        MyStack.prototype.push = function (x) {
            this.queue1.push(x);
        };

        /**
         * @return {number}
         */
        MyStack.prototype.pop = function () {
            while (this.queue1.length > 1) {
                this.queue2.push(this.queue1.shift());
                console.log(this.queue1);
            };
            let popItem = this.queue1.shift();
            while (this.queue2.length) {
                this.queue1.push(this.queue2.shift());
            };
            return popItem;

        };

        /**
         * @return {number}
         */
        MyStack.prototype.top = function () {
            return this.queue1[this.queue1.length - 1];
        };

        /**
         * @return {boolean}
         */
        MyStack.prototype.empty = function () {
            return this.queue1.length === 0
        };

        /**
         * Your MyStack object will be instantiated and called as such:
         * var obj = new MyStack()
         * obj.push(x)
         * var param_2 = obj.pop()
         * var param_3 = obj.top()
         * var param_4 = obj.empty()
         */

         function run() {
             let mstack = new MyStack();
             mstack.push(1);
             mstack.push(2);
             mstack.push(3);
             mstack.pop()
         };
         run()



    </script>
</body>

</html>