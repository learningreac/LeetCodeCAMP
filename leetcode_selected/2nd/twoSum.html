<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title></title>
</head>

<body>
    <script type="text/javascript">
        //1. two sum
        // 坑1： 原始数组中可能出现重复的数字，比如[3,3], target=6；
        // 坑2： 返回的是Index，所以如果对原始排序，要注意保留之前的顺序。
        // 坑3： 数字可能会是负数，负数的指针操作跟正数不一样。
        /*
        const twoSum = function (numbers, target) {
            let result= [];
            let copyNum = [...numbers].sort((a,b) => a-b);

           let left=0;
           let right=numbers.length-1; 

           while(left<right) {
               if(copyNum[left]+copyNum[right] > target) {
                   right--;
               } else if(copyNum[left] + copyNum[right] < target) {
                   left++;
               } else {
                   let firstIdx = numbers.indexOf(copyNum[left]); 
                   let secondIdx = numbers.indexOf(copyNum[right], firstIdx+1); // 2nd params: start from index
                   result.push(firstIdx);
                   result.push(secondIdx);
                   break;
               }
           };

           return result; // return the orginal index in numbers array; 
        };
        */

        //for 暴力解法
        const twoSum = function (numbers, target) {
            const result = [];
            for (let i = 0; i < numbers.length - 1; i++) {
                for (let j = i + 1; j < numbers.length; j++) {
                    if (numbers[i] + numbers[j] === target) {
                        result.push(i);
                        result.push(j);
                    }
                }
            };
            return result;
        };

        // harsh map for key-value pair  num -> index
        const twoSumSet = function (numbers, target) {
            const result = [];
            const harshMap = new Map();

            for (let i = 0; i < numbers.length; i++) {
                const newTarget = target - numbers[i];
                let j = harshMap.get(newTarget);
                harshMap.set(numbers[i], i);
                if (j !== undefined && j !== i) {
                    result.push(i);
                    result.push(j);
                }
            };
            return result;
        };

        //2. Add Two Numbers
        const list1 = {
            val: 2,
            next: {
                val: 4,
                next: {
                    val: 3,
                    next: {
                        val: 8,
                        next: null
                    }
                }
            }
        };

        const list2 = {
            val: 5,
            next: {
                val: 6,
                next: {
                    val: 4,
                    next: null
                }
            }
        };

        function ListNode(val, next) {
            this.val = (val === undefined ? 0 : val)
            this.next = (next === undefined ? null : next)
        };


        const addTwoNumbers = function (l1, l2) {
            let Dumhead = new ListNode();
            let cur = Dumhead;

            let add = 0;

            while (l1 || l2) {
                l1 ? value1 = l1.val : value1 = 0;
                l2 ? value2 = l2.val : value2 = 0;

                let sum = value1 + value2 + add;
                add = Math.floor(sum / 10); // 进位值
                sum = sum % 10; // 当前值

                if (l1) { l1 = l1.next }; // 这里是if里是l1, 如果是l1.next的话，指针就动不了了
                if (l2) { l2 = l2.next };

                cur.next = new ListNode(sum);
                cur = cur.next;
            };

            if (add === 1) {
                cur.next = new ListNode(add)
            }

            return Dumhead.next;
        };

        // addTwoNumbers(list1, list2);

        //剑指 Offer II 091. 粉刷房子
        // 基本思路对，因为房子只有3种可能的颜色，所以算每行的最小值，不必这么复杂。
        const minCost = function (costs) {
            const m = costs.length;
            const n = costs[0].length;

            const dp = new Array(m).fill(0).map(item => new Array(n).fill(0));
            dp[0] = costs[0];
            let min = rowMin(dp[0]);
            let pre_index = dp[0].indexOf(min);

            for (let i = 1; i < m; i++) {
                for (let j = 0; j < n; j++) {
                    dp[i][j] = j === pre_index ? costs[i][j] + rowMin(dp[i - 1], pre_index) : costs[i][j] + min;
                };

                min = rowMin(dp[i]);
                pre_index = dp[i].indexOf(min);
            };
            console.log(dp);

            return min;
        };

        const rowMin = function (arr, index) {
            let min = 100;
            for (let i = 0; i < arr.length; i++) {
                if (i === index) {
                    continue;
                } else {
                    min = Math.min(min, arr[i]);
                }
            };
            return min;
        };

        // minCost([[17,2,17],[16,16,5],[14,3,19]]);

        //22.括号生成
        const generateParenthesis = n => {
            if (!n) return [''];
            const res = [];

            const dfs = (path, left, right) => {
                // 去除无效括号
                // 左括号不能过半，右括号数量不能超过左括号
                if (left > n || right > left) return;
                //生成n对有效括号
                if (path.length === 2 * n) {
                    res.push(path);
                    return;
                };
                //追加左括号
                dfs(`${path}(`, left + 1, right);
                //追加右括号
                dfs(`${path})`, left, right + 1);
            };

            dfs('', 0, 0);
            return res;
        };

        //143 重排链表
        // 找到链表的中点，把后半段反转，然后拼接在一起
        const reverseLinkedList = head => {
            let pre = null;
            while (head) {
                let tmp = head.next;
                head.next = pre;
                pre = head;
                head = tmp;
            };

            return pre;
        };

        const middleNode = function (head) {
            let slow = head;
            let fast = head;

            while (fast !== null && fast.next != null) {
                slow = slow.next;
                fast = fast.next.next;
            }

            return slow;
        };

        const mergeLinkedList = (list1, list2) => {
            while (list1 && list2) {
                let tmp1 = list1.next;
                let tmp2 = list2.next;

                list1.next = list2;
                list1 = tmp1;

                list2.next = list1;
                list2 = tmp2;

            }
        };

        const reorderList = function (head) {
            if (head === null) return;

            let midNode = middleNode(head);
            let l1 = head;
            let l2 = midNode.next;
            midNode.next = null;// 截断left部分
            l2 = reverseLinkedList(l2);

            mergeLinkedList(l1, l2)
        };

        // 思路2 存入数组
        const reorderList2 = head => {
            if (!head) return null;
            let dumh = head;
            const listArr = [];

            while (dumh) {
                listArr.push(dumh);
                dumh = dumh.next;
            };

            let left = 1, right = listArr.length - 1;

            while (left <= right) {
                head.next = listArr[right];
                right--;
                head = head.next;
                head.next = listArr[left];
                left++;
                head = head.next;
            }

            head.next = null;
        };


        //31. Next Permutation
        //12385764 --12386457
        //12 - 21        

        const nextPermutation = function (nums) {
            if (nums.length === 1) return nums;
            let i = nums.length - 2;

            for (i; i >= 0; i--) {
                let cur = nums[i];
                let next = nums[i + 1];
                if (cur < next) {
                    break;
                };
            }
            let start = 0;
            if (i !== 0) {
                let k = nums.length - 1;
                for (k; k >= i + 1; k--) {
                    if (nums[k] > nums[i]) break;
                };

                // swap i and k
                [nums[i], nums[k]] = [nums[k], nums[i]];
                start = i + 1;
            }

            // reorder i+1 to end; bubble
            for (let l = start; l < nums.length; l++) {
                for (let j = l + 1; j < nums.length - l; j++) {
                    if (nums[l] > nums[j]) {
                        [nums[l], nums[j]] = [nums[j], nums[l]]
                    };
                }
            };

            return nums;
        };


        // 912 sort array
        // 1. merge sort 
        //执行用时：4580 ms,在所有 JavaScript 提交中击败了17.28%的用户
        const _mergeArray = (a,b) => {
            const c=[];

            while(a.length && b.length) {
                c.push( a[0] > b[0]? b.shift() : a.shift())
            };

            // a might not be equal length with b
            while(a.length) {
                c.push(a.shift());
            };

            while(b.length) {
                c.push(b.shift())
            };

            return c;
        }
        sortArray = function (nums) {
            if(nums.length===1) return nums;

            const middle = Math.floor(nums.length/2);
            const nums_l = nums.slice(0, middle);
            const nums_r = nums.slice(middle);
            
            return _mergeArray(sortArray(nums_l), sortArray(nums_r));
        };

       sortArray([5,1,1,2,0,0]);



    </script>

</body>

</html>