<!DOCTYPE html>
<html>
<head>
	<title></title>
</head>
<body>
	<p>思路1：利用array.reverse()</p>
	<p>思路2：递归，压栈</p>
	<p>思路3：直接用栈</p>
	<script type="text/javascript">
		/**
		 * Definition for singly-linked list.
		 * function ListNode(val) {
		 *     this.val = val;
		 *     this.next = null;
		 * }
		 */
		/**
		 * @param {ListNode} head
		 * @return {number[]}
		 */

		 const mylist = {
		 	val:1,
		 	next:{
		 		val:2,
		 		next:{
		 			val:3,
		 			next:null
		 		}
		 	}
		 }

		 const print1 = function(node){
		 	while(node != null){
		 		console.log(node.val)
		 		node=node.next;
		 	};
		 } //1,2,3

 		 const print2 = function(node,arr){
		 	while(node != null){
		 		arr.push(node.val)
		 		node=node.next;
		 	};

		 	return arr;
		 }; //[1,2,3]


		let arr1 = [1,2];
		let arr2 = [...arr1,3]; //[1,2,3]

		const print3 = function(node,arr){
			//arr.push(node.val);
			arr =  [...arr,node.val];
			console.log(arr);
			return arr;
		}; //print one node at a time


		 //print(mylist);




		 //1. Array.reverse()
		const reversePrint1 = function(head) {
			let res = [];

			while(head){
				res.push(head.val);
				head = head.next;
			};

			return res.reverse();

		}

		//reversePrint(mylist);


		//RECURSION

		const reversePrint2 = function(head) {
			let tmp = []

			const print = function(node){
				if(node === null) return;
				print(node.next);
				tmp.push(node.val)
				console.log(tmp)
			}

			print(head);

			return tmp;
		};


		//STACK
		const reversePrint = function(head) {
			let tmp = [];

			while(head){
				tmp.push(head.val);
				head = head.next;
			};

			console.log(tmp);
			let res = new Array(tmp.length);
			for(let i=0;i<res.length;i++){ // 这里如果写成i<=tmp.length 在tmp.pop()之后，tmp的长度就变化了
				res[i]=tmp.pop(); // 写成res.push(tmp.pop())也会报错
			};

			return res;

		}


		//reversePrint(mylist)
		

		

		

	</script>

</body>
</html>